import React from 'react';

var propTypes$1 = {exports: {}};

var reactIs = {exports: {}};

var reactIs_production_min = {};

/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var hasRequiredReactIs_production_min;

function requireReactIs_production_min () {
	if (hasRequiredReactIs_production_min) return reactIs_production_min;
	hasRequiredReactIs_production_min = 1;
var b="function"===typeof Symbol&&Symbol.for,c=b?Symbol.for("react.element"):60103,d=b?Symbol.for("react.portal"):60106,e=b?Symbol.for("react.fragment"):60107,f=b?Symbol.for("react.strict_mode"):60108,g=b?Symbol.for("react.profiler"):60114,h=b?Symbol.for("react.provider"):60109,k=b?Symbol.for("react.context"):60110,l=b?Symbol.for("react.async_mode"):60111,m=b?Symbol.for("react.concurrent_mode"):60111,n=b?Symbol.for("react.forward_ref"):60112,p=b?Symbol.for("react.suspense"):60113,q=b?
	Symbol.for("react.suspense_list"):60120,r=b?Symbol.for("react.memo"):60115,t=b?Symbol.for("react.lazy"):60116,v=b?Symbol.for("react.block"):60121,w=b?Symbol.for("react.fundamental"):60117,x=b?Symbol.for("react.responder"):60118,y=b?Symbol.for("react.scope"):60119;
	function z(a){if("object"===typeof a&&null!==a){var u=a.$$typeof;switch(u){case c:switch(a=a.type,a){case l:case m:case e:case g:case f:case p:return a;default:switch(a=a&&a.$$typeof,a){case k:case n:case t:case r:case h:return a;default:return u}}case d:return u}}}function A(a){return z(a)===m}reactIs_production_min.AsyncMode=l;reactIs_production_min.ConcurrentMode=m;reactIs_production_min.ContextConsumer=k;reactIs_production_min.ContextProvider=h;reactIs_production_min.Element=c;reactIs_production_min.ForwardRef=n;reactIs_production_min.Fragment=e;reactIs_production_min.Lazy=t;reactIs_production_min.Memo=r;reactIs_production_min.Portal=d;
	reactIs_production_min.Profiler=g;reactIs_production_min.StrictMode=f;reactIs_production_min.Suspense=p;reactIs_production_min.isAsyncMode=function(a){return A(a)||z(a)===l};reactIs_production_min.isConcurrentMode=A;reactIs_production_min.isContextConsumer=function(a){return z(a)===k};reactIs_production_min.isContextProvider=function(a){return z(a)===h};reactIs_production_min.isElement=function(a){return "object"===typeof a&&null!==a&&a.$$typeof===c};reactIs_production_min.isForwardRef=function(a){return z(a)===n};reactIs_production_min.isFragment=function(a){return z(a)===e};reactIs_production_min.isLazy=function(a){return z(a)===t};
	reactIs_production_min.isMemo=function(a){return z(a)===r};reactIs_production_min.isPortal=function(a){return z(a)===d};reactIs_production_min.isProfiler=function(a){return z(a)===g};reactIs_production_min.isStrictMode=function(a){return z(a)===f};reactIs_production_min.isSuspense=function(a){return z(a)===p};
	reactIs_production_min.isValidElementType=function(a){return "string"===typeof a||"function"===typeof a||a===e||a===m||a===g||a===f||a===p||a===q||"object"===typeof a&&null!==a&&(a.$$typeof===t||a.$$typeof===r||a.$$typeof===h||a.$$typeof===k||a.$$typeof===n||a.$$typeof===w||a.$$typeof===x||a.$$typeof===y||a.$$typeof===v)};reactIs_production_min.typeOf=z;
	return reactIs_production_min;
}

var reactIs_development = {};

/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var hasRequiredReactIs_development;

function requireReactIs_development () {
	if (hasRequiredReactIs_development) return reactIs_development;
	hasRequiredReactIs_development = 1;



	if (process.env.NODE_ENV !== "production") {
	  (function() {

	// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
	// nor polyfill, then a plain number is used for performance.
	var hasSymbol = typeof Symbol === 'function' && Symbol.for;
	var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
	var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
	var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
	var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
	var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
	var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
	var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
	// (unstable) APIs that have been removed. Can we remove the symbols?

	var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
	var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
	var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
	var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
	var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;
	var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
	var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;
	var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;
	var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;
	var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;
	var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;

	function isValidElementType(type) {
	  return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
	  type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
	}

	function typeOf(object) {
	  if (typeof object === 'object' && object !== null) {
	    var $$typeof = object.$$typeof;

	    switch ($$typeof) {
	      case REACT_ELEMENT_TYPE:
	        var type = object.type;

	        switch (type) {
	          case REACT_ASYNC_MODE_TYPE:
	          case REACT_CONCURRENT_MODE_TYPE:
	          case REACT_FRAGMENT_TYPE:
	          case REACT_PROFILER_TYPE:
	          case REACT_STRICT_MODE_TYPE:
	          case REACT_SUSPENSE_TYPE:
	            return type;

	          default:
	            var $$typeofType = type && type.$$typeof;

	            switch ($$typeofType) {
	              case REACT_CONTEXT_TYPE:
	              case REACT_FORWARD_REF_TYPE:
	              case REACT_LAZY_TYPE:
	              case REACT_MEMO_TYPE:
	              case REACT_PROVIDER_TYPE:
	                return $$typeofType;

	              default:
	                return $$typeof;
	            }

	        }

	      case REACT_PORTAL_TYPE:
	        return $$typeof;
	    }
	  }

	  return undefined;
	} // AsyncMode is deprecated along with isAsyncMode

	var AsyncMode = REACT_ASYNC_MODE_TYPE;
	var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
	var ContextConsumer = REACT_CONTEXT_TYPE;
	var ContextProvider = REACT_PROVIDER_TYPE;
	var Element = REACT_ELEMENT_TYPE;
	var ForwardRef = REACT_FORWARD_REF_TYPE;
	var Fragment = REACT_FRAGMENT_TYPE;
	var Lazy = REACT_LAZY_TYPE;
	var Memo = REACT_MEMO_TYPE;
	var Portal = REACT_PORTAL_TYPE;
	var Profiler = REACT_PROFILER_TYPE;
	var StrictMode = REACT_STRICT_MODE_TYPE;
	var Suspense = REACT_SUSPENSE_TYPE;
	var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated

	function isAsyncMode(object) {
	  {
	    if (!hasWarnedAboutDeprecatedIsAsyncMode) {
	      hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint

	      console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');
	    }
	  }

	  return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
	}
	function isConcurrentMode(object) {
	  return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
	}
	function isContextConsumer(object) {
	  return typeOf(object) === REACT_CONTEXT_TYPE;
	}
	function isContextProvider(object) {
	  return typeOf(object) === REACT_PROVIDER_TYPE;
	}
	function isElement(object) {
	  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
	}
	function isForwardRef(object) {
	  return typeOf(object) === REACT_FORWARD_REF_TYPE;
	}
	function isFragment(object) {
	  return typeOf(object) === REACT_FRAGMENT_TYPE;
	}
	function isLazy(object) {
	  return typeOf(object) === REACT_LAZY_TYPE;
	}
	function isMemo(object) {
	  return typeOf(object) === REACT_MEMO_TYPE;
	}
	function isPortal(object) {
	  return typeOf(object) === REACT_PORTAL_TYPE;
	}
	function isProfiler(object) {
	  return typeOf(object) === REACT_PROFILER_TYPE;
	}
	function isStrictMode(object) {
	  return typeOf(object) === REACT_STRICT_MODE_TYPE;
	}
	function isSuspense(object) {
	  return typeOf(object) === REACT_SUSPENSE_TYPE;
	}

	reactIs_development.AsyncMode = AsyncMode;
	reactIs_development.ConcurrentMode = ConcurrentMode;
	reactIs_development.ContextConsumer = ContextConsumer;
	reactIs_development.ContextProvider = ContextProvider;
	reactIs_development.Element = Element;
	reactIs_development.ForwardRef = ForwardRef;
	reactIs_development.Fragment = Fragment;
	reactIs_development.Lazy = Lazy;
	reactIs_development.Memo = Memo;
	reactIs_development.Portal = Portal;
	reactIs_development.Profiler = Profiler;
	reactIs_development.StrictMode = StrictMode;
	reactIs_development.Suspense = Suspense;
	reactIs_development.isAsyncMode = isAsyncMode;
	reactIs_development.isConcurrentMode = isConcurrentMode;
	reactIs_development.isContextConsumer = isContextConsumer;
	reactIs_development.isContextProvider = isContextProvider;
	reactIs_development.isElement = isElement;
	reactIs_development.isForwardRef = isForwardRef;
	reactIs_development.isFragment = isFragment;
	reactIs_development.isLazy = isLazy;
	reactIs_development.isMemo = isMemo;
	reactIs_development.isPortal = isPortal;
	reactIs_development.isProfiler = isProfiler;
	reactIs_development.isStrictMode = isStrictMode;
	reactIs_development.isSuspense = isSuspense;
	reactIs_development.isValidElementType = isValidElementType;
	reactIs_development.typeOf = typeOf;
	  })();
	}
	return reactIs_development;
}

var hasRequiredReactIs;

function requireReactIs () {
	if (hasRequiredReactIs) return reactIs.exports;
	hasRequiredReactIs = 1;

	if (process.env.NODE_ENV === 'production') {
	  reactIs.exports = requireReactIs_production_min();
	} else {
	  reactIs.exports = requireReactIs_development();
	}
	return reactIs.exports;
}

/*
object-assign
(c) Sindre Sorhus
@license MIT
*/

var objectAssign;
var hasRequiredObjectAssign;

function requireObjectAssign () {
	if (hasRequiredObjectAssign) return objectAssign;
	hasRequiredObjectAssign = 1;
	/* eslint-disable no-unused-vars */
	var getOwnPropertySymbols = Object.getOwnPropertySymbols;
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var propIsEnumerable = Object.prototype.propertyIsEnumerable;

	function toObject(val) {
		if (val === null || val === undefined) {
			throw new TypeError('Object.assign cannot be called with null or undefined');
		}

		return Object(val);
	}

	function shouldUseNative() {
		try {
			if (!Object.assign) {
				return false;
			}

			// Detect buggy property enumeration order in older V8 versions.

			// https://bugs.chromium.org/p/v8/issues/detail?id=4118
			var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
			test1[5] = 'de';
			if (Object.getOwnPropertyNames(test1)[0] === '5') {
				return false;
			}

			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test2 = {};
			for (var i = 0; i < 10; i++) {
				test2['_' + String.fromCharCode(i)] = i;
			}
			var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
				return test2[n];
			});
			if (order2.join('') !== '0123456789') {
				return false;
			}

			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test3 = {};
			'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
				test3[letter] = letter;
			});
			if (Object.keys(Object.assign({}, test3)).join('') !==
					'abcdefghijklmnopqrst') {
				return false;
			}

			return true;
		} catch (err) {
			// We don't expect any of the above to throw, but better to be safe.
			return false;
		}
	}

	objectAssign = shouldUseNative() ? Object.assign : function (target, source) {
		var from;
		var to = toObject(target);
		var symbols;

		for (var s = 1; s < arguments.length; s++) {
			from = Object(arguments[s]);

			for (var key in from) {
				if (hasOwnProperty.call(from, key)) {
					to[key] = from[key];
				}
			}

			if (getOwnPropertySymbols) {
				symbols = getOwnPropertySymbols(from);
				for (var i = 0; i < symbols.length; i++) {
					if (propIsEnumerable.call(from, symbols[i])) {
						to[symbols[i]] = from[symbols[i]];
					}
				}
			}
		}

		return to;
	};
	return objectAssign;
}

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var ReactPropTypesSecret_1;
var hasRequiredReactPropTypesSecret;

function requireReactPropTypesSecret () {
	if (hasRequiredReactPropTypesSecret) return ReactPropTypesSecret_1;
	hasRequiredReactPropTypesSecret = 1;

	var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

	ReactPropTypesSecret_1 = ReactPropTypesSecret;
	return ReactPropTypesSecret_1;
}

var has;
var hasRequiredHas;

function requireHas () {
	if (hasRequiredHas) return has;
	hasRequiredHas = 1;
	has = Function.call.bind(Object.prototype.hasOwnProperty);
	return has;
}

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var checkPropTypes_1;
var hasRequiredCheckPropTypes;

function requireCheckPropTypes () {
	if (hasRequiredCheckPropTypes) return checkPropTypes_1;
	hasRequiredCheckPropTypes = 1;

	var printWarning = function() {};

	if (process.env.NODE_ENV !== 'production') {
	  var ReactPropTypesSecret = requireReactPropTypesSecret();
	  var loggedTypeFailures = {};
	  var has = requireHas();

	  printWarning = function(text) {
	    var message = 'Warning: ' + text;
	    if (typeof console !== 'undefined') {
	      console.error(message);
	    }
	    try {
	      // --- Welcome to debugging React ---
	      // This error was thrown as a convenience so that you can use this stack
	      // to find the callsite that caused this warning to fire.
	      throw new Error(message);
	    } catch (x) { /**/ }
	  };
	}

	/**
	 * Assert that the values match with the type specs.
	 * Error messages are memorized and will only be shown once.
	 *
	 * @param {object} typeSpecs Map of name to a ReactPropType
	 * @param {object} values Runtime values that need to be type-checked
	 * @param {string} location e.g. "prop", "context", "child context"
	 * @param {string} componentName Name of the component for error messages.
	 * @param {?Function} getStack Returns the component stack.
	 * @private
	 */
	function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
	  if (process.env.NODE_ENV !== 'production') {
	    for (var typeSpecName in typeSpecs) {
	      if (has(typeSpecs, typeSpecName)) {
	        var error;
	        // Prop type validation may throw. In case they do, we don't want to
	        // fail the render phase where it didn't fail before. So we log it.
	        // After these have been cleaned up, we'll let them throw.
	        try {
	          // This is intentionally an invariant that gets caught. It's the same
	          // behavior as without this statement except with a better message.
	          if (typeof typeSpecs[typeSpecName] !== 'function') {
	            var err = Error(
	              (componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' +
	              'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' +
	              'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.'
	            );
	            err.name = 'Invariant Violation';
	            throw err;
	          }
	          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
	        } catch (ex) {
	          error = ex;
	        }
	        if (error && !(error instanceof Error)) {
	          printWarning(
	            (componentName || 'React class') + ': type specification of ' +
	            location + ' `' + typeSpecName + '` is invalid; the type checker ' +
	            'function must return `null` or an `Error` but returned a ' + typeof error + '. ' +
	            'You may have forgotten to pass an argument to the type checker ' +
	            'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' +
	            'shape all require an argument).'
	          );
	        }
	        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
	          // Only monitor this failure once because there tends to be a lot of the
	          // same error.
	          loggedTypeFailures[error.message] = true;

	          var stack = getStack ? getStack() : '';

	          printWarning(
	            'Failed ' + location + ' type: ' + error.message + (stack != null ? stack : '')
	          );
	        }
	      }
	    }
	  }
	}

	/**
	 * Resets warning cache when testing.
	 *
	 * @private
	 */
	checkPropTypes.resetWarningCache = function() {
	  if (process.env.NODE_ENV !== 'production') {
	    loggedTypeFailures = {};
	  }
	};

	checkPropTypes_1 = checkPropTypes;
	return checkPropTypes_1;
}

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var factoryWithTypeCheckers;
var hasRequiredFactoryWithTypeCheckers;

function requireFactoryWithTypeCheckers () {
	if (hasRequiredFactoryWithTypeCheckers) return factoryWithTypeCheckers;
	hasRequiredFactoryWithTypeCheckers = 1;

	var ReactIs = requireReactIs();
	var assign = requireObjectAssign();

	var ReactPropTypesSecret = requireReactPropTypesSecret();
	var has = requireHas();
	var checkPropTypes = requireCheckPropTypes();

	var printWarning = function() {};

	if (process.env.NODE_ENV !== 'production') {
	  printWarning = function(text) {
	    var message = 'Warning: ' + text;
	    if (typeof console !== 'undefined') {
	      console.error(message);
	    }
	    try {
	      // --- Welcome to debugging React ---
	      // This error was thrown as a convenience so that you can use this stack
	      // to find the callsite that caused this warning to fire.
	      throw new Error(message);
	    } catch (x) {}
	  };
	}

	function emptyFunctionThatReturnsNull() {
	  return null;
	}

	factoryWithTypeCheckers = function(isValidElement, throwOnDirectAccess) {
	  /* global Symbol */
	  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
	  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

	  /**
	   * Returns the iterator method function contained on the iterable object.
	   *
	   * Be sure to invoke the function with the iterable as context:
	   *
	   *     var iteratorFn = getIteratorFn(myIterable);
	   *     if (iteratorFn) {
	   *       var iterator = iteratorFn.call(myIterable);
	   *       ...
	   *     }
	   *
	   * @param {?object} maybeIterable
	   * @return {?function}
	   */
	  function getIteratorFn(maybeIterable) {
	    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
	    if (typeof iteratorFn === 'function') {
	      return iteratorFn;
	    }
	  }

	  /**
	   * Collection of methods that allow declaration and validation of props that are
	   * supplied to React components. Example usage:
	   *
	   *   var Props = require('ReactPropTypes');
	   *   var MyArticle = React.createClass({
	   *     propTypes: {
	   *       // An optional string prop named "description".
	   *       description: Props.string,
	   *
	   *       // A required enum prop named "category".
	   *       category: Props.oneOf(['News','Photos']).isRequired,
	   *
	   *       // A prop named "dialog" that requires an instance of Dialog.
	   *       dialog: Props.instanceOf(Dialog).isRequired
	   *     },
	   *     render: function() { ... }
	   *   });
	   *
	   * A more formal specification of how these methods are used:
	   *
	   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
	   *   decl := ReactPropTypes.{type}(.isRequired)?
	   *
	   * Each and every declaration produces a function with the same signature. This
	   * allows the creation of custom validation functions. For example:
	   *
	   *  var MyLink = React.createClass({
	   *    propTypes: {
	   *      // An optional string or URI prop named "href".
	   *      href: function(props, propName, componentName) {
	   *        var propValue = props[propName];
	   *        if (propValue != null && typeof propValue !== 'string' &&
	   *            !(propValue instanceof URI)) {
	   *          return new Error(
	   *            'Expected a string or an URI for ' + propName + ' in ' +
	   *            componentName
	   *          );
	   *        }
	   *      }
	   *    },
	   *    render: function() {...}
	   *  });
	   *
	   * @internal
	   */

	  var ANONYMOUS = '<<anonymous>>';

	  // Important!
	  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
	  var ReactPropTypes = {
	    array: createPrimitiveTypeChecker('array'),
	    bigint: createPrimitiveTypeChecker('bigint'),
	    bool: createPrimitiveTypeChecker('boolean'),
	    func: createPrimitiveTypeChecker('function'),
	    number: createPrimitiveTypeChecker('number'),
	    object: createPrimitiveTypeChecker('object'),
	    string: createPrimitiveTypeChecker('string'),
	    symbol: createPrimitiveTypeChecker('symbol'),

	    any: createAnyTypeChecker(),
	    arrayOf: createArrayOfTypeChecker,
	    element: createElementTypeChecker(),
	    elementType: createElementTypeTypeChecker(),
	    instanceOf: createInstanceTypeChecker,
	    node: createNodeChecker(),
	    objectOf: createObjectOfTypeChecker,
	    oneOf: createEnumTypeChecker,
	    oneOfType: createUnionTypeChecker,
	    shape: createShapeTypeChecker,
	    exact: createStrictShapeTypeChecker,
	  };

	  /**
	   * inlined Object.is polyfill to avoid requiring consumers ship their own
	   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
	   */
	  /*eslint-disable no-self-compare*/
	  function is(x, y) {
	    // SameValue algorithm
	    if (x === y) {
	      // Steps 1-5, 7-10
	      // Steps 6.b-6.e: +0 != -0
	      return x !== 0 || 1 / x === 1 / y;
	    } else {
	      // Step 6.a: NaN == NaN
	      return x !== x && y !== y;
	    }
	  }
	  /*eslint-enable no-self-compare*/

	  /**
	   * We use an Error-like object for backward compatibility as people may call
	   * PropTypes directly and inspect their output. However, we don't use real
	   * Errors anymore. We don't inspect their stack anyway, and creating them
	   * is prohibitively expensive if they are created too often, such as what
	   * happens in oneOfType() for any type before the one that matched.
	   */
	  function PropTypeError(message, data) {
	    this.message = message;
	    this.data = data && typeof data === 'object' ? data: {};
	    this.stack = '';
	  }
	  // Make `instanceof Error` still work for returned errors.
	  PropTypeError.prototype = Error.prototype;

	  function createChainableTypeChecker(validate) {
	    if (process.env.NODE_ENV !== 'production') {
	      var manualPropTypeCallCache = {};
	      var manualPropTypeWarningCount = 0;
	    }
	    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
	      componentName = componentName || ANONYMOUS;
	      propFullName = propFullName || propName;

	      if (secret !== ReactPropTypesSecret) {
	        if (throwOnDirectAccess) {
	          // New behavior only for users of `prop-types` package
	          var err = new Error(
	            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
	            'Use `PropTypes.checkPropTypes()` to call them. ' +
	            'Read more at http://fb.me/use-check-prop-types'
	          );
	          err.name = 'Invariant Violation';
	          throw err;
	        } else if (process.env.NODE_ENV !== 'production' && typeof console !== 'undefined') {
	          // Old behavior for people using React.PropTypes
	          var cacheKey = componentName + ':' + propName;
	          if (
	            !manualPropTypeCallCache[cacheKey] &&
	            // Avoid spamming the console because they are often not actionable except for lib authors
	            manualPropTypeWarningCount < 3
	          ) {
	            printWarning(
	              'You are manually calling a React.PropTypes validation ' +
	              'function for the `' + propFullName + '` prop on `' + componentName + '`. This is deprecated ' +
	              'and will throw in the standalone `prop-types` package. ' +
	              'You may be seeing this warning due to a third-party PropTypes ' +
	              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.'
	            );
	            manualPropTypeCallCache[cacheKey] = true;
	            manualPropTypeWarningCount++;
	          }
	        }
	      }
	      if (props[propName] == null) {
	        if (isRequired) {
	          if (props[propName] === null) {
	            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
	          }
	          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
	        }
	        return null;
	      } else {
	        return validate(props, propName, componentName, location, propFullName);
	      }
	    }

	    var chainedCheckType = checkType.bind(null, false);
	    chainedCheckType.isRequired = checkType.bind(null, true);

	    return chainedCheckType;
	  }

	  function createPrimitiveTypeChecker(expectedType) {
	    function validate(props, propName, componentName, location, propFullName, secret) {
	      var propValue = props[propName];
	      var propType = getPropType(propValue);
	      if (propType !== expectedType) {
	        // `propValue` being instance of, say, date/regexp, pass the 'object'
	        // check, but we can offer a more precise error message here rather than
	        // 'of type `object`'.
	        var preciseType = getPreciseType(propValue);

	        return new PropTypeError(
	          'Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'),
	          {expectedType: expectedType}
	        );
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createAnyTypeChecker() {
	    return createChainableTypeChecker(emptyFunctionThatReturnsNull);
	  }

	  function createArrayOfTypeChecker(typeChecker) {
	    function validate(props, propName, componentName, location, propFullName) {
	      if (typeof typeChecker !== 'function') {
	        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
	      }
	      var propValue = props[propName];
	      if (!Array.isArray(propValue)) {
	        var propType = getPropType(propValue);
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
	      }
	      for (var i = 0; i < propValue.length; i++) {
	        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
	        if (error instanceof Error) {
	          return error;
	        }
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createElementTypeChecker() {
	    function validate(props, propName, componentName, location, propFullName) {
	      var propValue = props[propName];
	      if (!isValidElement(propValue)) {
	        var propType = getPropType(propValue);
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createElementTypeTypeChecker() {
	    function validate(props, propName, componentName, location, propFullName) {
	      var propValue = props[propName];
	      if (!ReactIs.isValidElementType(propValue)) {
	        var propType = getPropType(propValue);
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement type.'));
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createInstanceTypeChecker(expectedClass) {
	    function validate(props, propName, componentName, location, propFullName) {
	      if (!(props[propName] instanceof expectedClass)) {
	        var expectedClassName = expectedClass.name || ANONYMOUS;
	        var actualClassName = getClassName(props[propName]);
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createEnumTypeChecker(expectedValues) {
	    if (!Array.isArray(expectedValues)) {
	      if (process.env.NODE_ENV !== 'production') {
	        if (arguments.length > 1) {
	          printWarning(
	            'Invalid arguments supplied to oneOf, expected an array, got ' + arguments.length + ' arguments. ' +
	            'A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).'
	          );
	        } else {
	          printWarning('Invalid argument supplied to oneOf, expected an array.');
	        }
	      }
	      return emptyFunctionThatReturnsNull;
	    }

	    function validate(props, propName, componentName, location, propFullName) {
	      var propValue = props[propName];
	      for (var i = 0; i < expectedValues.length; i++) {
	        if (is(propValue, expectedValues[i])) {
	          return null;
	        }
	      }

	      var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
	        var type = getPreciseType(value);
	        if (type === 'symbol') {
	          return String(value);
	        }
	        return value;
	      });
	      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + String(propValue) + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createObjectOfTypeChecker(typeChecker) {
	    function validate(props, propName, componentName, location, propFullName) {
	      if (typeof typeChecker !== 'function') {
	        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
	      }
	      var propValue = props[propName];
	      var propType = getPropType(propValue);
	      if (propType !== 'object') {
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
	      }
	      for (var key in propValue) {
	        if (has(propValue, key)) {
	          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
	          if (error instanceof Error) {
	            return error;
	          }
	        }
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createUnionTypeChecker(arrayOfTypeCheckers) {
	    if (!Array.isArray(arrayOfTypeCheckers)) {
	      process.env.NODE_ENV !== 'production' ? printWarning('Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
	      return emptyFunctionThatReturnsNull;
	    }

	    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
	      var checker = arrayOfTypeCheckers[i];
	      if (typeof checker !== 'function') {
	        printWarning(
	          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +
	          'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.'
	        );
	        return emptyFunctionThatReturnsNull;
	      }
	    }

	    function validate(props, propName, componentName, location, propFullName) {
	      var expectedTypes = [];
	      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
	        var checker = arrayOfTypeCheckers[i];
	        var checkerResult = checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret);
	        if (checkerResult == null) {
	          return null;
	        }
	        if (checkerResult.data && has(checkerResult.data, 'expectedType')) {
	          expectedTypes.push(checkerResult.data.expectedType);
	        }
	      }
	      var expectedTypesMessage = (expectedTypes.length > 0) ? ', expected one of type [' + expectedTypes.join(', ') + ']': '';
	      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`' + expectedTypesMessage + '.'));
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createNodeChecker() {
	    function validate(props, propName, componentName, location, propFullName) {
	      if (!isNode(props[propName])) {
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function invalidValidatorError(componentName, location, propFullName, key, type) {
	    return new PropTypeError(
	      (componentName || 'React class') + ': ' + location + ' type `' + propFullName + '.' + key + '` is invalid; ' +
	      'it must be a function, usually from the `prop-types` package, but received `' + type + '`.'
	    );
	  }

	  function createShapeTypeChecker(shapeTypes) {
	    function validate(props, propName, componentName, location, propFullName) {
	      var propValue = props[propName];
	      var propType = getPropType(propValue);
	      if (propType !== 'object') {
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
	      }
	      for (var key in shapeTypes) {
	        var checker = shapeTypes[key];
	        if (typeof checker !== 'function') {
	          return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
	        }
	        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
	        if (error) {
	          return error;
	        }
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createStrictShapeTypeChecker(shapeTypes) {
	    function validate(props, propName, componentName, location, propFullName) {
	      var propValue = props[propName];
	      var propType = getPropType(propValue);
	      if (propType !== 'object') {
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
	      }
	      // We need to check all keys in case some are required but missing from props.
	      var allKeys = assign({}, props[propName], shapeTypes);
	      for (var key in allKeys) {
	        var checker = shapeTypes[key];
	        if (has(shapeTypes, key) && typeof checker !== 'function') {
	          return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
	        }
	        if (!checker) {
	          return new PropTypeError(
	            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +
	            '\nBad object: ' + JSON.stringify(props[propName], null, '  ') +
	            '\nValid keys: ' + JSON.stringify(Object.keys(shapeTypes), null, '  ')
	          );
	        }
	        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
	        if (error) {
	          return error;
	        }
	      }
	      return null;
	    }

	    return createChainableTypeChecker(validate);
	  }

	  function isNode(propValue) {
	    switch (typeof propValue) {
	      case 'number':
	      case 'string':
	      case 'undefined':
	        return true;
	      case 'boolean':
	        return !propValue;
	      case 'object':
	        if (Array.isArray(propValue)) {
	          return propValue.every(isNode);
	        }
	        if (propValue === null || isValidElement(propValue)) {
	          return true;
	        }

	        var iteratorFn = getIteratorFn(propValue);
	        if (iteratorFn) {
	          var iterator = iteratorFn.call(propValue);
	          var step;
	          if (iteratorFn !== propValue.entries) {
	            while (!(step = iterator.next()).done) {
	              if (!isNode(step.value)) {
	                return false;
	              }
	            }
	          } else {
	            // Iterator will provide entry [k,v] tuples rather than values.
	            while (!(step = iterator.next()).done) {
	              var entry = step.value;
	              if (entry) {
	                if (!isNode(entry[1])) {
	                  return false;
	                }
	              }
	            }
	          }
	        } else {
	          return false;
	        }

	        return true;
	      default:
	        return false;
	    }
	  }

	  function isSymbol(propType, propValue) {
	    // Native Symbol.
	    if (propType === 'symbol') {
	      return true;
	    }

	    // falsy value can't be a Symbol
	    if (!propValue) {
	      return false;
	    }

	    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
	    if (propValue['@@toStringTag'] === 'Symbol') {
	      return true;
	    }

	    // Fallback for non-spec compliant Symbols which are polyfilled.
	    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
	      return true;
	    }

	    return false;
	  }

	  // Equivalent of `typeof` but with special handling for array and regexp.
	  function getPropType(propValue) {
	    var propType = typeof propValue;
	    if (Array.isArray(propValue)) {
	      return 'array';
	    }
	    if (propValue instanceof RegExp) {
	      // Old webkits (at least until Android 4.0) return 'function' rather than
	      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
	      // passes PropTypes.object.
	      return 'object';
	    }
	    if (isSymbol(propType, propValue)) {
	      return 'symbol';
	    }
	    return propType;
	  }

	  // This handles more types than `getPropType`. Only used for error messages.
	  // See `createPrimitiveTypeChecker`.
	  function getPreciseType(propValue) {
	    if (typeof propValue === 'undefined' || propValue === null) {
	      return '' + propValue;
	    }
	    var propType = getPropType(propValue);
	    if (propType === 'object') {
	      if (propValue instanceof Date) {
	        return 'date';
	      } else if (propValue instanceof RegExp) {
	        return 'regexp';
	      }
	    }
	    return propType;
	  }

	  // Returns a string that is postfixed to a warning about an invalid type.
	  // For example, "undefined" or "of type array"
	  function getPostfixForTypeWarning(value) {
	    var type = getPreciseType(value);
	    switch (type) {
	      case 'array':
	      case 'object':
	        return 'an ' + type;
	      case 'boolean':
	      case 'date':
	      case 'regexp':
	        return 'a ' + type;
	      default:
	        return type;
	    }
	  }

	  // Returns class name of the object, if any.
	  function getClassName(propValue) {
	    if (!propValue.constructor || !propValue.constructor.name) {
	      return ANONYMOUS;
	    }
	    return propValue.constructor.name;
	  }

	  ReactPropTypes.checkPropTypes = checkPropTypes;
	  ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
	  ReactPropTypes.PropTypes = ReactPropTypes;

	  return ReactPropTypes;
	};
	return factoryWithTypeCheckers;
}

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var factoryWithThrowingShims;
var hasRequiredFactoryWithThrowingShims;

function requireFactoryWithThrowingShims () {
	if (hasRequiredFactoryWithThrowingShims) return factoryWithThrowingShims;
	hasRequiredFactoryWithThrowingShims = 1;

	var ReactPropTypesSecret = requireReactPropTypesSecret();

	function emptyFunction() {}
	function emptyFunctionWithReset() {}
	emptyFunctionWithReset.resetWarningCache = emptyFunction;

	factoryWithThrowingShims = function() {
	  function shim(props, propName, componentName, location, propFullName, secret) {
	    if (secret === ReactPropTypesSecret) {
	      // It is still safe when called from React.
	      return;
	    }
	    var err = new Error(
	      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
	      'Use PropTypes.checkPropTypes() to call them. ' +
	      'Read more at http://fb.me/use-check-prop-types'
	    );
	    err.name = 'Invariant Violation';
	    throw err;
	  }	  shim.isRequired = shim;
	  function getShim() {
	    return shim;
	  }	  // Important!
	  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
	  var ReactPropTypes = {
	    array: shim,
	    bigint: shim,
	    bool: shim,
	    func: shim,
	    number: shim,
	    object: shim,
	    string: shim,
	    symbol: shim,

	    any: shim,
	    arrayOf: getShim,
	    element: shim,
	    elementType: shim,
	    instanceOf: getShim,
	    node: shim,
	    objectOf: getShim,
	    oneOf: getShim,
	    oneOfType: getShim,
	    shape: getShim,
	    exact: getShim,

	    checkPropTypes: emptyFunctionWithReset,
	    resetWarningCache: emptyFunction
	  };

	  ReactPropTypes.PropTypes = ReactPropTypes;

	  return ReactPropTypes;
	};
	return factoryWithThrowingShims;
}

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if (process.env.NODE_ENV !== 'production') {
  var ReactIs = requireReactIs();

  // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
  var throwOnDirectAccess = true;
  propTypes$1.exports = requireFactoryWithTypeCheckers()(ReactIs.isElement, throwOnDirectAccess);
} else {
  // By explicitly using `prop-types` you are opting into new production behavior.
  // http://fb.me/prop-types-in-prod
  propTypes$1.exports = requireFactoryWithThrowingShims()();
}

var propTypesExports = propTypes$1.exports;

const namespace = "react-swiftreveal";
const defaults = { duration: 1e3, delay: 0, count: 1 };
let ssr = true;
let observerMode = false;
let raf = (cb) => setTimeout(cb, 66);
const disableSsr = () => {
  ssr = false;
};
let fadeOutEnabled = false;
let globalHide = false;
let collapseend;
let counter = 1;
const effectMap = {};
let sheet = null;
const name$c = `${namespace}-${Math.floor(Math.random() * 1e15)}-`;
const insertRule = (rule) => {
  try {
    return sheet?.insertRule(rule, sheet.cssRules.length);
  } catch (e) {
    console.warn("react-swiftreveal - animation failed");
  }
};
const cascade = (i, start, end, duration, total) => {
  const minv = Math.log(duration);
  const maxv = Math.log(total);
  const scale = (maxv - minv) / (end - start);
  return Math.exp(minv + scale * (i - start));
};
const animation = (effect) => {
  if (!sheet)
    return "";
  const rule = `@keyframes ${name$c + counter}{${effect}}`;
  const effectId = effectMap[effect];
  if (!effectId) {
    insertRule(rule);
    effectMap[effect] = counter;
    return `${name$c}${counter++}`;
  }
  return `${name$c}${effectId}`;
};
const hideAll = () => {
  if (globalHide)
    return;
  globalHide = true;
  window.removeEventListener("scroll", hideAll, true);
  insertRule(`.${namespace} { opacity: 0; }`);
  window.removeEventListener("orientationchange", hideAll, true);
  window.document.removeEventListener("visibilitychange", hideAll);
};
if (typeof window !== "undefined" && window.name !== "nodejs" && window.document && typeof navigator !== "undefined") {
  observerMode = "IntersectionObserver" in window && "IntersectionObserverEntry" in window && "intersectionRatio" in window.IntersectionObserverEntry.prototype && /\{\s*\[native code\]\s*\}/.test(`${IntersectionObserver}`);
  raf = window.requestAnimationFrame || raf;
  ssr = window.document.querySelectorAll("div[data-reactroot]").length > 0;
  if (navigator.appVersion.includes("MSIE 10"))
    ;
  if (ssr && "performance" in window && "timing" in window.performance && "domContentLoadedEventEnd" in window.performance.timing && window.performance.timing.domLoading && Date.now() - window.performance.timing.domLoading < 300)
    ssr = false;
  if (ssr)
    window.setTimeout(disableSsr, 1500);
  if (!observerMode) {
    collapseend = document.createEvent("Event");
    collapseend.initEvent("collapseend", true, true);
  }
  const element = document.createElement("style");
  document.head.appendChild(element);
  if (element.sheet && element.sheet.cssRules) {
    sheet = element.sheet;
    window.addEventListener("scroll", hideAll, true);
    window.addEventListener("orientationchange", hideAll, true);
    window.document.addEventListener("visibilitychange", hideAll);
  }
}

const inOut = propTypesExports.shape({
  make: propTypesExports.func,
  duration: propTypesExports.number.isRequired,
  delay: propTypesExports.number.isRequired,
  forever: propTypesExports.bool,
  count: propTypesExports.number.isRequired,
  style: propTypesExports.object.isRequired,
  reverse: propTypesExports.bool
}), propTypes = {
  //when: any,
  //spy: any,
  //margin: number,
  collapse: propTypesExports.bool,
  // oneOfType([bool, shape({ tag: string, props: object })]),
  collapseEl: propTypesExports.element,
  cascade: propTypesExports.bool,
  wait: propTypesExports.number,
  //    step: oneOfType([instanceOf(Step), string]),
  force: propTypesExports.bool,
  disabled: propTypesExports.bool,
  appear: propTypesExports.bool,
  enter: propTypesExports.bool,
  exit: propTypesExports.bool,
  fraction: propTypesExports.number,
  //children: element.isRequired,
  refProp: propTypesExports.string,
  innerRef: propTypesExports.func,
  onReveal: propTypesExports.func,
  //onEnter: func,
  //onEntering: func,
  //onEntered: func,
  //onExit: func,
  //onExiting: func,
  //onExited: func,
  unmountOnExit: propTypesExports.bool,
  mountOnEnter: propTypesExports.bool,
  inEffect: inOut.isRequired,
  outEffect: propTypesExports.oneOfType([inOut, propTypesExports.oneOf([false])]).isRequired,
  ssrReveal: propTypesExports.bool,
  collapseOnly: propTypesExports.bool,
  ssrFadeout: propTypesExports.bool
}, defaultProps = {
  fraction: 0.2,
  //when: true,
  refProp: "ref"
  //margin: 0,
}, contextTypes = {
  transitionGroup: propTypesExports.object
};
class RevealBase extends React.Component {
  //getChildContext() {
  //  return { transitionGroup: null }; // allows for nested Transitions
  //}
  constructor(props, context) {
    super(props, context);
    this.isOn = props.when !== void 0 ? !!props.when : true;
    this.state = {
      collapse: props.collapse ? RevealBase.getInitialCollapseStyle(props) : void 0,
      style: {
        opacity: (!this.isOn || props.ssrReveal) && props.outEffect ? 0 : void 0
        //visibility: props.when  ? 'visible' : 'hidden',
      }
    };
    this.savedChild = false;
    this.isShown = false;
    if (!observerMode) {
      this.revealHandler = this.makeHandler(this.reveal);
      this.resizeHandler = this.makeHandler(this.resize);
    } else
      this.handleObserve = this.handleObserve.bind(this);
    this.saveRef = this.saveRef.bind(this);
  }
  saveRef(node) {
    if (this.childRef)
      this.childRef(node);
    if (this.props.innerRef)
      this.props.innerRef(node);
    if (this.el !== node) {
      this.el = node && "offsetHeight" in node ? node : void 0;
      this.observe(this.props, true);
    }
  }
  invisible() {
    if (!this || !this.el)
      return;
    this.savedChild = false;
    if (!this.isShown) {
      this.setState({
        hasExited: true,
        collapse: this.props.collapse ? { ...this.state.collapse, visibility: "hidden" } : null,
        style: {
          /*...this.state.style, visibility: 'hidden'*/
          opacity: 0
        }
        /*, collapsing: false */
      });
      if (!observerMode && this.props.collapse)
        window.document.dispatchEvent(collapseend);
    }
  }
  animationEnd(func2, cascade2, { forever, count, delay, duration }) {
    if (forever)
      return;
    const handler = () => {
      if (!this || !this.el)
        return;
      this.animationEndTimeout = void 0;
      func2.call(this);
    };
    this.animationEndTimeout = window.setTimeout(handler, delay + (duration + (cascade2 ? duration : 0) * count));
  }
  getDimensionValue() {
    return this.el.offsetHeight + parseInt(window.getComputedStyle(this.el, null).getPropertyValue("margin-top"), 10) + parseInt(window.getComputedStyle(this.el, null).getPropertyValue("margin-bottom"), 10);
  }
  //    //const delta = this.props.duration>>2,
  //    //      duration = delta,
  //    //      delay = this.props.delay + (this.isOn ? 0 : this.props.duration - delta)
  collapse(state, props, inOut2) {
    const total = inOut2.duration + (props.cascade ? inOut2.duration : 0), height = this.isOn ? this.getDimensionValue() : 0;
    let duration, delay;
    if (props.collapseOnly) {
      duration = inOut2.duration / 3;
      delay = inOut2.delay;
    } else {
      let delta1 = total >> 2, delta2 = delta1 >> 1;
      duration = delta1;
      delay = inOut2.delay + (this.isOn ? 0 : total - delta1 - delta2);
      state.style.animationDuration = `${total - delta1 + (this.isOn ? delta2 : -delta2)}ms`;
      state.style.animationDelay = `${inOut2.delay + (this.isOn ? delta1 - delta2 : 0)}ms`;
    }
    state.collapse = {
      height,
      transition: `height ${duration}ms ease ${delay}ms`,
      // padding ${duration}ms ease ${delay}ms, border ${duration}ms ease ${delay}ms`,
      overflow: props.collapseOnly ? "hidden" : void 0
      //margin: 0, padding: 0, border: '1px solid transparent',
      //boxSizing: 'border-box',
    };
    return state;
  }
  animate(props) {
    if (!this || !this.el)
      return;
    this.unlisten();
    if (this.isShown === this.isOn)
      return;
    this.isShown = this.isOn;
    const leaving = !this.isOn && props.outEffect, inOut2 = props[leaving ? "outEffect" : "inEffect"];
    let animationName = "style" in inOut2 && inOut2.style.animationName || void 0;
    let state;
    if (!props.collapseOnly) {
      if ((props.outEffect || this.isOn) && inOut2.make)
        animationName = inOut2.make;
      state = {
        /* status: leaving ? 'exiting':'entering',*/
        hasAppeared: true,
        hasExited: false,
        collapse: void 0,
        style: {
          ...inOut2.style,
          animationDuration: `${inOut2.duration}ms`,
          animationDelay: `${inOut2.delay}ms`,
          animationIterationCount: inOut2.forever ? "infinite" : inOut2.count,
          opacity: 1,
          //visibility: 'visible',
          animationName
        },
        className: inOut2.className
      };
    } else
      state = { hasAppeared: true, hasExited: false, style: { opacity: 1 } };
    this.setState(props.collapse ? this.collapse(state, props, inOut2) : state);
    if (leaving) {
      this.savedChild = React.cloneElement(this.getChild());
      this.animationEnd(this.invisible, props.cascade, inOut2);
    } else
      this.savedChild = false;
    this.onReveal(props);
  }
  onReveal(props) {
    if (props.onReveal && this.isOn) {
      if (this.onRevealTimeout)
        this.onRevealTimeout = window.clearTimeout(this.onRevealTimeout);
      props.wait ? this.onRevealTimeout = window.setTimeout(props.onReveal, props.wait) : props.onReveal();
    }
  }
  componentWillUnmount() {
    this.unlisten();
    ssr && disableSsr();
  }
  handleObserve([entry], observer) {
    if (entry.intersectionRatio > 0) {
      observer.disconnect();
      this.observer = null;
      this.reveal(this.props, true);
    }
  }
  observe(props, update = false) {
    if (!this.el)
      return;
    if (observerMode) {
      if (this.observer) {
        if (update)
          this.observer.disconnect();
        else
          return;
      } else if (update)
        return;
      this.observer = new IntersectionObserver(this.handleObserve, { threshold: props.fraction });
      this.observer.observe(this.el);
    }
  }
  reveal(props, inView = false) {
    if (!globalHide)
      hideAll();
    if (!this || !this.el)
      return;
    if (!props)
      props = this.props;
    if (ssr)
      disableSsr();
    if (this.isOn && this.isShown && props.spy !== void 0) {
      this.isShown = false;
      this.setState({ style: {} });
      window.setTimeout(() => this.reveal(props), 200);
    } else if (inView || this.inViewport(props) || props.force)
      this.animate(props);
    else
      observerMode ? this.observe(props) : this.listen();
  }
  componentDidMount() {
    if (!this.el || this.props.disabled)
      return;
    if (!this.props.collapseOnly) {
      if ("make" in this.props.inEffect)
        this.props.inEffect.make(false, this.props);
      if (this.props.when !== void 0 && this.props.outEffect && "make" in this.props.outEffect)
        this.props.outEffect.make(true, this.props);
    }
    const parentGroup = this.context.transitionGroup;
    const appear = parentGroup && !parentGroup.isMounting ? !("enter" in this.props && this.props.enter === false) : this.props.appear;
    if (this.isOn && ((this.props.when !== void 0 || this.props.spy !== void 0) && !appear || ssr && !fadeOutEnabled && !this.props.ssrFadeout && this.props.outEffect && !this.props.ssrReveal && RevealBase.getTop(this.el) < window.pageYOffset + window.innerHeight)) {
      this.isShown = true;
      this.setState({
        hasAppeared: true,
        collapse: this.props.collapse ? { height: this.getDimensionValue() } : this.state.collapse,
        style: { opacity: 1 }
      });
      this.onReveal(this.props);
      return;
    }
    if (ssr && (this.props.ssrFadeout) && this.props.outEffect && RevealBase.getTop(this.el) < window.pageYOffset + window.innerHeight) {
      this.setState({ style: { opacity: 0, transition: "opacity 1000ms 1000ms" } });
      window.setTimeout(() => this.reveal(this.props, true), 2e3);
      return;
    }
    if (this.isOn)
      this.props.force ? this.animate(this.props) : this.reveal(this.props);
  }
  cascade(children) {
    let newChildren;
    if (typeof children === "string") {
      newChildren = children.split("").map((ch, index) => /* @__PURE__ */ React.createElement("span", { key: index, style: { display: "inline-block", whiteSpace: "pre" } }, ch));
    } else
      newChildren = React.Children.toArray(children);
    let { duration, reverse } = this.props[this.isOn || !this.props.outEffect ? "inEffect" : "outEffect"], count = newChildren.length, total = duration * 2;
    if (this.props.collapse) {
      total = parseInt(this.state.style.animationDuration, 10);
      duration = total / 2;
    }
    let i = reverse ? count : 0;
    newChildren = newChildren.map((child) => typeof child === "object" && child ? React.cloneElement(child, {
      style: {
        ...child.props.style,
        ...this.state.style,
        animationDuration: Math.round(cascade(reverse ? i-- : i++, 0, count, duration, total)) + "ms"
      }
      //ref: i === count? (el => this.finalEl = el) : void 0,
    }) : child);
    return newChildren;
  }
  static getInitialCollapseStyle(props) {
    return {
      height: 0,
      visibility: props.when ? void 0 : "hidden"
    };
  }
  componentWillReceiveProps(props) {
    if (props.when !== void 0)
      this.isOn = !!props.when;
    if (props.fraction !== this.props.fraction)
      this.observe(props, true);
    if (!this.isOn && props.onExited && "exit" in props && props.exit === false) {
      props.onExited();
      return;
    }
    if (props.disabled)
      return;
    if (props.collapse && !this.props.collapse) {
      this.setState({ style: {}, collapse: RevealBase.getInitialCollapseStyle(props) });
      this.isShown = false;
    }
    if (props.when !== this.props.when || props.spy !== this.props.spy)
      this.reveal(props);
    if (this.onRevealTimeout && !this.isOn)
      this.onRevealTimeout = window.clearTimeout(this.onRevealTimeout);
  }
  getChild() {
    if (this.savedChild && !this.props.disabled)
      return this.savedChild;
    if (typeof this.props.children === "object") {
      const child = React.Children.only(this.props.children);
      return "type" in child && typeof child.type === "string" || this.props.refProp !== "ref" ? child : /* @__PURE__ */ React.createElement("div", null, child);
    } else
      return /* @__PURE__ */ React.createElement("div", null, this.props.children);
  }
  render() {
    let mount;
    if (!this.state.hasAppeared)
      mount = !this.props.mountOnEnter || this.isOn;
    else
      mount = !this.props.unmountOnExit || !this.state.hasExited || this.isOn;
    const child = this.getChild();
    if (typeof child.ref === "function")
      this.childRef = child.ref;
    let newChildren = false, { style, className, children } = child.props;
    let newClass = this.props.disabled ? className : `${this.props.outEffect ? namespace : ""}${this.state.className ? " " + this.state.className : ""}${className ? " " + className : ""}` || void 0, newStyle;
    if (typeof this.state.style.animationName === "function")
      this.state.style.animationName = this.state.style.animationName(!this.isOn, this.props);
    if (this.props.cascade && !this.props.disabled && children && this.state.style.animationName) {
      newChildren = this.cascade(children);
      newStyle = { ...style, opacity: 1 };
    } else
      newStyle = this.props.disabled ? style : { ...style, ...this.state.style };
    const props = { ...this.props.props, className: newClass, style: newStyle, [this.props.refProp]: this.saveRef };
    const el = React.cloneElement(child, props, mount ? newChildren || children : void 0);
    if (this.props.collapse !== void 0)
      return this.props.collapseEl ? React.cloneElement(this.props.collapseEl, { style: { ...this.props.collapseEl.style, ...this.props.disabled ? void 0 : this.state.collapse }, children: el }) : /* @__PURE__ */ React.createElement("div", { style: this.props.disabled ? void 0 : this.state.collapse, children: el });
    return el;
  }
  makeHandler(handler) {
    const update = () => {
      handler.call(this, this.props);
      this.ticking = false;
    };
    return () => {
      if (!this.ticking) {
        raf(update);
        this.ticking = true;
      }
    };
  }
  static getTop(el) {
    while (el.offsetTop === void 0)
      el = el.parentNode;
    let top = el.offsetTop;
    for (; el.offsetParent; top += el.offsetTop)
      el = el.offsetParent;
    return top;
  }
  inViewport(props) {
    if (!this.el || window.document.hidden)
      return false;
    const h = this.el.offsetHeight, delta = window.pageYOffset - RevealBase.getTop(this.el), tail = Math.min(h, window.innerHeight) * (globalHide ? props.fraction : 0);
    return delta > tail - window.innerHeight && delta < h - tail;
  }
  resize(props) {
    if (!this || !this.el || !this.isOn)
      return;
    if (this.inViewport(props)) {
      this.unlisten();
      this.isShown = this.isOn;
      this.setState({ hasExited: !this.isOn, hasAppeared: true, collapse: void 0, style: { opacity: this.isOn || !props.outEffect ? 1 : 0 } });
      this.onReveal(props);
    }
  }
  listen() {
    if (!observerMode && !this.isListener) {
      this.isListener = true;
      window.addEventListener("scroll", this.revealHandler, { passive: true });
      window.addEventListener("orientationchange", this.revealHandler, { passive: true });
      window.document.addEventListener("visibilitychange", this.revealHandler, { passive: true });
      window.document.addEventListener("collapseend", this.revealHandler, { passive: true });
      window.addEventListener("resize", this.resizeHandler, { passive: true });
    }
  }
  unlisten() {
    if (!observerMode && this.isListener) {
      window.removeEventListener("scroll", this.revealHandler, { passive: true });
      window.removeEventListener("orientationchange", this.revealHandler, { passive: true });
      window.document.removeEventListener("visibilitychange", this.revealHandler, { passive: true });
      window.document.removeEventListener("collapseend", this.revealHandler, { passive: true });
      window.removeEventListener("resize", this.resizeHandler, { passive: true });
      this.isListener = false;
    }
    if (this.onRevealTimeout)
      this.onRevealTimeout = window.clearTimeout(this.onRevealTimeout);
    if (this.animationEndTimeout)
      this.animationEndTimeout = window.clearTimeout(this.animationEndTimeout);
  }
}
RevealBase.propTypes = propTypes;
RevealBase.defaultProps = defaultProps;
RevealBase.contextTypes = contextTypes;
RevealBase.displayName = "RevealBase";
const RevealBase$1 = RevealBase;

function wrapper(props, inEffect, outEffect, children) {
  if ("in" in props)
    props.when = props.in;
  if (React.Children.count(children) < 2)
    return /* @__PURE__ */ React.createElement(RevealBase$1, { ...props, inEffect, outEffect, children });
  children = React.Children.map(
    children,
    (child) => /* @__PURE__ */ React.createElement(RevealBase$1, { ...props, inEffect, outEffect, children: child })
  );
  return "Fragment" in React ? /* @__PURE__ */ React.createElement(React.Fragment, null, children) : /* @__PURE__ */ React.createElement("span", null, children);
}

const rule$b = `
 from, 20%, 53%, 80%, to {
    animation-timing-function: cubic-bezier(0.215, 0.610, 0.355, 1.000);
    transform: translate3d(0,0,0);
  }

  40%, 43% {
    animation-timing-function: cubic-bezier(0.755, 0.050, 0.855, 0.060);
    transform: translate3d(0, -30px, 0);
  }

  70% {
    animation-timing-function: cubic-bezier(0.755, 0.050, 0.855, 0.060);
    transform: translate3d(0, -15px, 0);
  }

  90% {
    transform: translate3d(0, -4px, 0);
}
`;
let name$b;
function make$i() {
  return name$b || (name$b = animation(rule$b));
}
function Jump({
  children,
  // eslint-disable-next-line unused-imports/no-unused-vars
  out,
  timeout,
  duration = defaults.duration,
  delay = defaults.delay,
  count = defaults.count,
  forever,
  ...props
} = defaults) {
  const effect = { make: make$i, duration: timeout === void 0 ? duration : timeout, delay, forever, count, style: { animationFillMode: "both" } };
  return wrapper(props, effect, false, children);
}

const rule$a = `
  from {
    transform: scale(1);
  }

  50% {
    transform: scale(1.1);
  }

  to {
    transform: scale(1);
  }
`;
let name$a;
function make$h() {
  return name$a || (name$a = animation(rule$a));
}
function Pop({
  children,
  // eslint-disable-next-line unused-imports/no-unused-vars
  out,
  timeout,
  duration = defaults.duration,
  delay = defaults.delay,
  count = defaults.count,
  forever,
  ...props
} = defaults) {
  const effect = { make: make$h, duration: timeout === void 0 ? duration : timeout, delay, forever, count, style: { animationFillMode: "both" } };
  return wrapper(props, effect, false, children);
}

const rule$9 = `
  from, 11.1%, to {
    transform: none;
  }

  22.2% {
    transform: skewX(-12.5deg) skewY(-12.5deg);
  }

  33.3% {
    transform: skewX(6.25deg) skewY(6.25deg);
  }

  44.4% {
    transform: skewX(-3.125deg) skewY(-3.125deg);
  }

  55.5% {
    transform: skewX(1.5625deg) skewY(1.5625deg);
  }

  66.6% {
    transform: skewX(-0.78125deg) skewY(-0.78125deg);
  }

  77.7% {
    transform: skewX(0.390625deg) skewY(0.390625deg);
  }

  88.8% {
    transform: skewX(-0.1953125deg) skewY(-0.1953125deg);
}
`;
let name$9;
function make$g() {
  return name$9 || (name$9 = animation(rule$9));
}
function Jello({
  children,
  // eslint-disable-next-line unused-imports/no-unused-vars
  out,
  timeout,
  duration = defaults.duration,
  delay = defaults.delay,
  count = defaults.count,
  forever,
  ...props
} = defaults) {
  const effect = { make: make$g, duration: timeout === void 0 ? duration : timeout, delay, forever, count, style: { animationFillMode: "both" } };
  return wrapper(props, effect, false, children);
}

const rule$8 = `
from, 50%, to {
    opacity: 1;
  }

  25%, 75% {
    opacity: 0;
}
`;
let name$8;
function make$f() {
  return name$8 || (name$8 = animation(rule$8));
}
function Flash({
  children,
  // eslint-disable-next-line unused-imports/no-unused-vars
  out,
  timeout,
  duration = defaults.duration,
  delay = defaults.delay,
  count = defaults.count,
  forever,
  ...props
} = defaults) {
  const effect = { make: make$f, duration: timeout === void 0 ? duration : timeout, delay, forever, count, style: { animationFillMode: "both" } };
  return wrapper(props, effect, false, children);
}

const rule$7 = `
  0% {
    transform: translateX(0);
  }

  6.5% {
    transform: translateX(-6px) rotateY(-9deg);
  }

  18.5% {
    transform: translateX(5px) rotateY(7deg);
  }

  31.5% {
    transform: translateX(-3px) rotateY(-5deg);
  }

  43.5% {
    transform: translateX(2px) rotateY(3deg);
  }

  50% {
    transform: translateX(0);
}
`;
let name$7;
function make$e() {
  return name$7 || (name$7 = animation(rule$7));
}
function HeadShake({
  children,
  // eslint-disable-next-line unused-imports/no-unused-vars
  out,
  timeout,
  duration = defaults.duration,
  delay = defaults.delay,
  count = defaults.count,
  forever,
  ...props
} = defaults) {
  const effect = { make: make$e, duration: timeout === void 0 ? duration : timeout, delay, forever, count, style: { animationFillMode: "both" } };
  return wrapper(props, effect, false, children);
}

const rule$6 = `
	from {
    transform: scale3d(1, 1, 1);
  }

  50% {
    transform: scale3d(1.05, 1.05, 1.05);
  }

  to {
    transform: scale3d(1, 1, 1);
}`;
let name$6;
function make$d() {
  return name$6 || (name$6 = animation(rule$6));
}
function Pulse({
  children,
  // eslint-disable-next-line unused-imports/no-unused-vars
  out,
  timeout,
  duration = defaults.duration,
  delay = defaults.delay,
  count = defaults.count,
  forever,
  ...props
} = defaults) {
  const effect = { make: make$d, duration: timeout === void 0 ? duration : timeout, delay, forever, count, style: { animationFillMode: "both" } };
  return wrapper(props, effect, false, children);
}

const rule$5 = `
 from {
    transform: scale3d(1, 1, 1);
  }

  30% {
    transform: scale3d(1.25, 0.75, 1);
  }

  40% {
    transform: scale3d(0.75, 1.25, 1);
  }

  50% {
    transform: scale3d(1.15, 0.85, 1);
  }

  65% {
    transform: scale3d(.95, 1.05, 1);
  }

  75% {
    transform: scale3d(1.05, .95, 1);
  }

  to {
    transform: scale3d(1, 1, 1);
}
`;
let name$5;
function make$c() {
  return name$5 || (name$5 = animation(rule$5));
}
function RubberBand({
  children,
  // eslint-disable-next-line unused-imports/no-unused-vars
  out,
  timeout,
  duration = defaults.duration,
  delay = defaults.delay,
  count = defaults.count,
  forever,
  ...props
} = defaults) {
  const effect = { make: make$c, duration: timeout === void 0 ? duration : timeout, delay, forever, count, style: { animationFillMode: "both" } };
  return wrapper(props, effect, false, children);
}

const rule$4 = `
  from, to {
    transform: translate3d(0, 0, 0);
  }

  10%, 30%, 50%, 70%, 90% {
    transform: translate3d(-10px, 0, 0);
  }

  20%, 40%, 60%, 80% {
    transform: translate3d(10px, 0, 0);
  }
`;
const name$4 = animation(rule$4);
function Shake({
  children,
  // eslint-disable-next-line unused-imports/no-unused-vars
  out,
  timeout,
  duration = defaults.duration,
  delay = defaults.delay,
  count = defaults.count,
  forever,
  ...props
} = defaults) {
  const effect = { make: () => name$4, duration: timeout === void 0 ? duration : timeout, delay, forever, count, style: { animationFillMode: "both" } };
  return wrapper(props, effect, false, children);
}

const rule$3 = `
    from {
        transform: rotate(360deg);
        animation-timing-function: linear;
    }

    to {
       transform: rotate(0deg);
    }
`;
let name$3;
function make$b() {
  return name$3 || (name$3 = animation(rule$3));
}
function Spin({
  children,
  // eslint-disable-next-line unused-imports/no-unused-vars
  out,
  timeout,
  duration = defaults.duration,
  delay = defaults.delay,
  count = defaults.count,
  forever,
  ...props
} = defaults) {
  const effect = { make: make$b, duration: timeout === void 0 ? duration : timeout, delay, forever, count, style: { animationFillMode: "both" } };
  return wrapper(props, effect, false, children);
}

const rule$2 = `
    20% {
        transform: rotate3d(0, 0, 1, 15deg);
    }

    40% {
        transform: rotate3d(0, 0, 1, -10deg);
    }

    60% {
        transform: rotate3d(0, 0, 1, 5deg);
    }

    80% {
        transform: rotate3d(0, 0, 1, -5deg);
    }

    to {
        transform: rotate3d(0, 0, 1, 0deg);
    }
`;
let name$2;
function make$a() {
  return name$2 || (name$2 = animation(rule$2));
}
function Swing({
  children,
  // eslint-disable-next-line unused-imports/no-unused-vars
  out,
  timeout,
  duration = defaults.duration,
  delay = defaults.delay,
  count = defaults.count,
  forever,
  ...props
} = defaults) {
  const effect = { make: make$a, duration: timeout === void 0 ? duration : timeout, delay, forever, count, style: { animationFillMode: "both" } };
  return wrapper(props, effect, false, children);
}

const rule$1 = `
    from {
        transform: scale3d(1, 1, 1);
    }

    10%, 20% {
        transform: scale3d(.9, .9, .9) rotate3d(0, 0, 1, -3deg);
    }

    30%, 50%, 70%, 90% {
        transform: scale3d(1.1, 1.1, 1.1) rotate3d(0, 0, 1, 3deg);
    }

    40%, 60%, 80% {
        transform: scale3d(1.1, 1.1, 1.1) rotate3d(0, 0, 1, -3deg);
    }

    to {
        transform: scale3d(1, 1, 1);
    }
`;
let name$1;
function make$9() {
  return name$1 || (name$1 = animation(rule$1));
}
function Tada({
  children,
  // eslint-disable-next-line unused-imports/no-unused-vars
  out,
  timeout,
  duration = defaults.duration,
  delay = defaults.delay,
  count = defaults.count,
  forever,
  ...props
} = defaults) {
  const effect = { make: make$9, duration: timeout === void 0 ? duration : timeout, delay, forever, count, style: { animationFillMode: "both" } };
  return wrapper(props, effect, false, children);
}

const rule = `
    from {
        transform: none;
    }

    15% {
        transform: translate3d(-25%, 0, 0) rotate3d(0, 0, 1, -5deg);
    }

    30% {
        transform: translate3d(20%, 0, 0) rotate3d(0, 0, 1, 3deg);
    }

    45% {
        transform: translate3d(-15%, 0, 0) rotate3d(0, 0, 1, -3deg);
    }

    60% {
        transform: translate3d(10%, 0, 0) rotate3d(0, 0, 1, 2deg);
    }

    75% {
        transform: translate3d(-5%, 0, 0) rotate3d(0, 0, 1, -1deg);
    }

    to {
        transform: none;
    }
`;
let name;
function make$8() {
  return name || (name = animation(rule));
}
function Wobble({
  children,
  // eslint-disable-next-line unused-imports/no-unused-vars
  out,
  timeout,
  duration = defaults.duration,
  delay = defaults.delay,
  count = defaults.count,
  forever,
  ...props
} = defaults) {
  const effect = { make: make$8, duration: timeout === void 0 ? duration : timeout, delay, forever, count, style: { animationFillMode: "both" } };
  return wrapper(props, effect, false, children);
}

const lookup$7 = {};
function make$7(reverse, { left, right, up, down, top, bottom, mirror, opposite }) {
  const checksum = (left ? 1 : 0) | (right ? 2 : 0) | (top || down ? 4 : 0) | (bottom || up ? 8 : 0) | (mirror ? 16 : 0) | (opposite ? 32 : 0) | (reverse ? 64 : 0);
  if (lookup$7.hasOwnProperty(checksum))
    return lookup$7[checksum];
  if (!mirror !== !(reverse && opposite))
    [left, right, top, bottom, up, down] = [right, left, bottom, top, down, up];
  let angle = "-200deg";
  let origin = "center";
  if ((down || top) && left)
    angle = "-45deg";
  if ((down || top) && right || (up || bottom) && left)
    angle = "45deg";
  if ((up || bottom) && right)
    angle = "-90deg";
  if (left || right)
    origin = `${left ? "left" : "right"} bottom`;
  lookup$7[checksum] = animation(`
    ${!reverse ? "from" : "to"} { opacity: 0; transform-origin: ${origin}; transform: rotate3d(0, 0, 1, ${angle});}
    ${reverse ? "from" : "to"} { opacity: 1; transform-origin: ${origin}; transform: none;}
  `);
  return lookup$7[checksum];
}
function Rotate({
  children,
  // eslint-disable-next-line unused-imports/no-unused-vars
  out,
  forever,
  timeout,
  duration = defaults.duration,
  delay = defaults.delay,
  count = defaults.count,
  ...props
} = defaults) {
  const effect = {
    make: make$7,
    duration: timeout === void 0 ? duration : timeout,
    delay,
    forever,
    count,
    style: { animationFillMode: "both" }
  };
  return wrapper(props, effect, effect, children);
}

const lookup$6 = {};
function make$6(reverse, { left, right, up, down, top, bottom, mirror, opposite }) {
  const checksum = (left ? 1 : 0) | (right ? 2 : 0) | (top || down ? 4 : 0) | (bottom || up ? 8 : 0) | (mirror ? 16 : 0) | (opposite ? 32 : 0) | (reverse ? 64 : 0);
  if (lookup$6.hasOwnProperty(checksum))
    return lookup$6[checksum];
  if (!mirror !== !(reverse && opposite))
    [left, right, top, bottom, up, down] = [right, left, bottom, top, down, up];
  const transformX = left || right;
  const transformY = top || bottom || up || down;
  const transform = transformX || transformY;
  let rule, x0, y0, x20, y20, y40, x60, y60, x75, y75, x90, y90, x100, y100;
  if (reverse) {
    x20 = transformX ? `${right ? "-" : ""}20px` : 0;
    y20 = transformY ? `${up || bottom ? "" : "-"}10px` : "0";
    y40 = `${down || top ? "" : "-"}20px`;
    x100 = transformX ? `${left ? "-" : ""}2000px` : "0";
    y100 = transformY ? `${down || top ? "-" : ""}2000px` : "0";
  } else {
    x0 = transformX ? `${left ? "-" : ""}3000px` : "0";
    y0 = transformY ? `${down || top ? "-" : ""}3000px` : "0";
    x60 = transformX ? `${right ? "-" : ""}25px` : "0";
    y60 = transformY ? `${up || bottom ? "-" : ""}25px` : "0";
    x75 = transformX ? `${left ? "-" : ""}10px` : "0";
    y75 = transformY ? `${down || top ? "-" : ""}10px` : "0";
    x90 = transformX ? `${right ? "-" : ""}5px` : "0";
    y90 = transformY ? `${up || bottom ? "-" : ""}5px` : "0";
  }
  if (transform) {
    rule = reverse ? `
        20% {
          transform: translate3d(${x20}, ${y20}, 0);
          }
        ${transformY ? `40%, 45% {
            opacity: 1;
            transform: translate3d(0, ${y40}, 0);
          }` : ""}
          to {
            opacity: 0;
            transform: translate3d(${x100}, ${y100}, 0);
        }
      ` : `from, 60%, 75%, 90%, to {
        animation-timing-function: cubic-bezier(0.215, 0.610, 0.355, 1.000);
      }
      from {
        opacity: 0;
        transform: translate3d(${x0}, ${y0}, 0);
      }
      60% {
        opacity: 1;
        transform: translate3d(${x60}, ${y60}, 0);
      }
      75% {
        transform: translate3d(${x75}, ${y75}, 0);
      }
      90% {
        transform: translate3d(${x90}, ${y90}, 0);
      }
      to {
        transform: none;
      }`;
  } else {
    rule = reverse ? `20% {
          transform: scale3d(.9, .9, .9);
        }
        50%, 55% {
          opacity: 1;
          transform: scale3d(1.1, 1.1, 1.1);
        }
        to {
          opacity: 0;
          transform: scale3d(.3, .3, .3);
      }` : `from, 20%, 40%, 60%, 80%, to {
        animation-timing-function: cubic-bezier(0.215, 0.610, 0.355, 1.000);
      }
      0% {
        opacity: 0;
        transform: scale3d(.3, .3, .3);
      }
      20% {
        transform: scale3d(1.1, 1.1, 1.1);
      }
      40% {
        transform: scale3d(.9, .9, .9);
      }
      60% {
        opacity: 1;
        transform: scale3d(1.03, 1.03, 1.03);
      }
      80% {
        transform: scale3d(.97, .97, .97);
      }
      to {
        opacity: 1;
        transform: scale3d(1, 1, 1);
      }`;
  }
  lookup$6[checksum] = animation(rule);
  return lookup$6[checksum];
}
function Bounce({
  children,
  // eslint-disable-next-line unused-imports/no-unused-vars
  out,
  forever,
  timeout,
  duration = defaults.duration,
  delay = defaults.delay,
  count = defaults.count,
  ...props
} = defaults) {
  const effect = {
    make: make$6,
    duration: timeout === void 0 ? duration : timeout,
    delay,
    forever,
    count,
    style: { animationFillMode: "both" },
    reverse: props.left
  };
  return wrapper(props, effect, effect, children);
}

const lookup$5 = {};
function make$5(reverse, { distance, left, right, up, down, top, bottom, big, mirror, opposite }) {
  const checksum = (distance ? distance.toString() : 0) + ((left ? 1 : 0) | (right ? 2 : 0) | (top || down ? 4 : 0) | (bottom || up ? 8 : 0) | (mirror ? 16 : 0) | (opposite ? 32 : 0) | (reverse ? 64 : 0) | (big ? 128 : 0));
  if (lookup$5.hasOwnProperty(checksum))
    return lookup$5[checksum];
  const transform = left || right || up || down || top || bottom;
  let x, y;
  if (transform) {
    if (!mirror !== !(reverse && opposite))
      [left, right, top, bottom, up, down] = [right, left, bottom, top, down, up];
    const dist = distance || (big ? "2000px" : "100%");
    x = left ? `-${dist}` : right ? dist : "0";
    y = down || top ? `-${dist}` : up || bottom ? dist : "0";
  }
  lookup$5[checksum] = animation(
    `${!reverse ? "from" : "to"} {opacity: 0;${transform ? ` transform: translate3d(${x}, ${y}, 0);` : ""}}
     ${reverse ? "from" : "to"} {opacity: 1;transform: none;} `
  );
  return lookup$5[checksum];
}
function Fade({
  children,
  // eslint-disable-next-line unused-imports/no-unused-vars
  out,
  forever,
  timeout,
  duration = defaults.duration,
  delay = defaults.delay,
  count = defaults.count,
  ...props
} = defaults) {
  const effect = {
    make: make$5,
    duration: timeout === void 0 ? duration : timeout,
    delay,
    forever,
    count,
    style: { animationFillMode: "both" },
    reverse: props.left
  };
  return wrapper(props, effect, effect, children);
}

const lookup$4 = {};
function make$4(reverse, { left, right, top, bottom, x, y, mirror, opposite }) {
  const checksum = (left ? 1 : 0) | (right || y ? 2 : 0) | (top || x ? 4 : 0) | (bottom ? 8 : 0) | (mirror ? 16 : 0) | (opposite ? 32 : 0) | (reverse ? 64 : 0);
  if (lookup$4.hasOwnProperty(checksum))
    return lookup$4[checksum];
  if (!mirror !== !(reverse && opposite))
    [left, right, top, bottom, x, y] = [right, left, bottom, top, y, x];
  let rule;
  if (x || y || left || right || top || bottom) {
    const xval = x || top || bottom ? `${bottom ? "-" : ""}1` : "0";
    const yval = y || right || left ? `${left ? "-" : ""}1` : "0";
    if (!reverse) {
      rule = `from {
          transform: perspective(400px) rotate3d(${xval}, ${yval}, 0, 90deg);
          animation-timing-function: ease-in;
          opacity: 0;
        }
        40% {
          transform: perspective(400px) rotate3d(${xval}, ${yval}, 0, -20deg);
          animation-timing-function: ease-in;
        }
        60% {
          transform: perspective(400px) rotate3d(${xval}, ${yval}, 0, 10deg);
          opacity: 1;
        }
        80% {
          transform: perspective(400px) rotate3d(${xval}, ${yval}, 0, -5deg);
        }
        to {
          transform: perspective(400px);
        }`;
    } else {
      rule = `from {
          transform: perspective(400px);
        }
        30% {
          transform: perspective(400px) rotate3d(${xval}, ${yval}, 0, -15deg);
          opacity: 1;
        }
        to {
          transform: perspective(400px) rotate3d(${xval}, ${yval}, 0, 90deg);
          opacity: 0;
        }`;
    }
  } else {
    rule = `from {
          transform: perspective(400px) rotate3d(0, 1, 0, -360deg);
          animation-timing-function: ease-out;
          opacity: ${!reverse ? "0" : "1"};
        }
        40% {
          transform: perspective(400px) translate3d(0, 0, 150px) rotate3d(0, 1, 0, -190deg);
          animation-timing-function: ease-out;
        }
        50% {
          transform: perspective(400px) translate3d(0, 0, 150px) rotate3d(0, 1, 0, -170deg);
          animation-timing-function: ease-in;
        }
        to {
          transform: perspective(400px);
          animation-timing-function: ease-in;
          opacity: ${reverse ? "0" : "1"};
        }`;
  }
  lookup$4[checksum] = animation(rule);
  return lookup$4[checksum];
}
function Flip({
  children,
  // eslint-disable-next-line unused-imports/no-unused-vars
  out,
  forever,
  timeout,
  duration = defaults.duration,
  delay = defaults.delay,
  count = defaults.count,
  ...props
} = defaults) {
  const effect = {
    make: make$4,
    duration: timeout === void 0 ? duration : timeout,
    delay,
    forever,
    count,
    style: { animationFillMode: "both", backfaceVisibility: "visible" }
  };
  return wrapper(props, effect, effect, children);
}

const lookup$3 = {};
function make$3(reverse, { left, right, mirror, opposite }) {
  const checksum = (left ? 1 : 0) | (right ? 2 : 0) | (mirror ? 16 : 0) | (opposite ? 32 : 0) | (reverse ? 64 : 0);
  if (lookup$3.hasOwnProperty(checksum))
    return lookup$3[checksum];
  if (!mirror !== !(reverse && opposite))
    [left, right] = [right, left];
  const dist = "100%";
  const x = left ? `-${dist}` : right ? dist : "0";
  const rule = !reverse ? `from {
        transform: translate3d(${x}, 0, 0) skewX(-30deg);
        opacity: 0;
      }
      60% {
        transform: skewX(20deg);
        opacity: 1;
      }
      80% {
        transform: skewX(-5deg);
        opacity: 1;
      }
      to {
        transform: none;
        opacity: 1;
      }` : `from {
        opacity: 1;
      }
      to {
        transform: translate3d(${x}, 0, 0) skewX(30deg);
        opacity: 0;
      }
    `;
  lookup$3[checksum] = animation(rule);
  return lookup$3[checksum];
}
function LightSpeed({
  children,
  // eslint-disable-next-line unused-imports/no-unused-vars
  out,
  forever,
  timeout,
  duration = defaults.duration,
  delay = defaults.delay,
  count = defaults.count,
  ...props
} = defaults) {
  const effect = {
    make: make$3,
    duration: timeout === void 0 ? duration : timeout,
    delay,
    forever,
    count,
    style: { animationFillMode: "both" }
  };
  0 + (props.left ? 1 : 0) + (props.right ? 10 : 0) + (props.mirror ? 1e4 : 0) + (props.opposite ? 1e5 : 0);
  return wrapper(props, effect, effect, children);
}

const lookup$2 = {};
function make$2(reverse, { left, right, up, down, top, bottom, big, mirror, opposite }) {
  const checksum = (left ? 1 : 0) | (right ? 2 : 0) | (top || down ? 4 : 0) | (bottom || up ? 8 : 0) | (mirror ? 16 : 0) | (opposite ? 32 : 0) | (reverse ? 64 : 0) | (big ? 128 : 0);
  if (lookup$2.hasOwnProperty(checksum))
    return lookup$2[checksum];
  if (!mirror !== !(reverse && opposite))
    [left, right, top, bottom, up, down] = [right, left, bottom, top, down, up];
  const dist = big ? "2000px" : "100%";
  const x = left ? `-${dist}` : right ? dist : "0";
  const y = down || top ? `-${dist}` : up || bottom ? dist : "0";
  lookup$2[checksum] = animation(`
    ${!reverse ? "from" : "to"} {opacity: 0;transform: translate3d(${x}, ${y}, 0) rotate3d(0, 0, 1, -120deg);}
	  ${reverse ? "from" : "to"} {opacity: 1;transform: none}
  `);
  return lookup$2[checksum];
}
function Roll({
  children,
  // eslint-disable-next-line unused-imports/no-unused-vars
  out,
  forever,
  timeout,
  duration = defaults.duration,
  delay = defaults.delay,
  count = defaults.count,
  ...props
} = defaults) {
  const effect = {
    make: make$2,
    duration: timeout === void 0 ? duration : timeout,
    delay,
    forever,
    count,
    style: { animationFillMode: "both" }
  };
  return wrapper(props, effect, effect, children);
}

const lookup$1 = {};
function make$1(reverse, { left, right, up, down, top, bottom, big, mirror, opposite }) {
  const checksum = (left ? 1 : 0) | (right ? 2 : 0) | (top || down ? 4 : 0) | (bottom || up ? 8 : 0) | (mirror ? 16 : 0) | (opposite ? 32 : 0) | (reverse ? 64 : 0) | (big ? 128 : 0);
  if (lookup$1.hasOwnProperty(checksum))
    return lookup$1[checksum];
  const transform = left || right || up || down || top || bottom;
  let x, y;
  if (transform) {
    if (!mirror !== !(reverse && opposite))
      [left, right, top, bottom, up, down] = [right, left, bottom, top, down, up];
    const dist = big ? "2000px" : "100%";
    x = left ? `-${dist}` : right ? dist : "0";
    y = down || top ? `-${dist}` : up || bottom ? dist : "0";
  }
  lookup$1[checksum] = animation(
    `${!reverse ? "from" : "to"} {${transform ? ` transform: translate3d(${x}, ${y}, 0);` : ""}}
     ${reverse ? "from" : "to"} {transform: none;} `
  );
  return lookup$1[checksum];
}
function Slide({
  children,
  // eslint-disable-next-line unused-imports/no-unused-vars
  out,
  forever,
  timeout,
  duration = defaults.duration,
  delay = defaults.delay,
  count = defaults.count,
  ...props
} = defaults) {
  const effect = {
    make: make$1,
    duration: timeout === void 0 ? duration : timeout,
    delay,
    forever,
    count,
    style: { animationFillMode: "both" },
    reverse: props.left
  };
  return wrapper(props, effect, effect, children);
}

const lookup = {};
function make(reverse, { left, right, up, down, top, bottom, mirror, opposite }) {
  const checksum = (left ? 1 : 0) | (right ? 2 : 0) | (top || down ? 4 : 0) | (bottom || up ? 8 : 0) | (mirror ? 16 : 0) | (opposite ? 32 : 0) | (reverse ? 64 : 0);
  if (lookup.hasOwnProperty(checksum))
    return lookup[checksum];
  if (!mirror !== !(reverse && opposite))
    [left, right, top, bottom, up, down] = [right, left, bottom, top, down, up];
  const transformX = left || right;
  const transformY = top || bottom || up || down;
  const transform = transformX || transformY;
  let rule, x1, y1, x2, y2;
  if (transform) {
    if (reverse) {
      x1 = transformX ? `${left ? "" : "-"}42px` : "0";
      y1 = transformY ? `${down || top ? "-" : ""}60px` : "0";
      x2 = transformX ? `${right ? "" : "-"}2000px` : "0";
      y2 = transformY ? `${up || bottom ? "" : "-"}2000px` : "0";
      rule = `40% {
          opacity: 1;
          transform: scale3d(.475, .475, .475) translate3d(${x1}, ${y1}, 0);
        }
        to {
          opacity: 0;
          transform: scale(.1) translate3d(${x2}, ${y2}, 0);
          transform-origin: ${transformY ? "center bottom" : `${left ? "left" : "right"} center`};
        }`;
    } else {
      x1 = transformX ? `${left ? "-" : ""}1000px` : "0";
      y1 = transformY ? `${down || top ? "-" : ""}1000px` : "0";
      x2 = transformX ? `${right ? "-" : ""}10px` : "0";
      y2 = transformY ? `${up || bottom ? "-" : ""}60px` : "0";
      rule = `from {
          opacity: 0;
          transform: scale3d(.1, .1, .1) translate3d(${x1}, ${y1}, 0);
          animation-timing-function: cubic-bezier(0.550, 0.055, 0.675, 0.190);
        }
        60% {
          opacity: 1;
          transform: scale3d(.475, .475, .475) translate3d(${x2}, ${y2}, 0);
          animation-timing-function: cubic-bezier(0.175, 0.885, 0.320, 1);
        }`;
    }
  } else {
    rule = `${!reverse ? "from" : "to"} {opacity: 0; transform: scale3d(.1, .1, .1);} ${reverse ? "from" : "to"} { opacity: 1; transform: none;}`;
  }
  lookup[checksum] = animation(rule);
  return lookup[checksum];
}
function Zoom({
  // eslint-disable-next-line unused-imports/no-unused-vars
  children,
  out,
  forever,
  timeout,
  duration = defaults.duration,
  delay = defaults.delay,
  count = defaults.count,
  ...props
} = defaults) {
  const effect = {
    make,
    duration: timeout === void 0 ? duration : timeout,
    delay,
    forever,
    count,
    style: { animationFillMode: "both" },
    reverse: props.left
  };
  return wrapper(props, effect, effect, children);
}

export { Bounce, Fade, Flash, Flip, HeadShake, Jello, Jump, LightSpeed, Pop, Pulse, Roll, Rotate, RubberBand, Shake, Slide, Spin, Swing, Tada, Wobble, Zoom };
