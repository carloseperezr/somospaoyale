import {
  __toESM,
  require_react
} from "./chunk-MYQCFY5U.js";

// node_modules/react-swift-reveal/dist/index.mjs
var import_react = __toESM(require_react(), 1);
var propTypes$1 = { exports: {} };
var reactIs = { exports: {} };
var reactIs_development = {};
var hasRequiredReactIs_development;
function requireReactIs_development() {
  if (hasRequiredReactIs_development)
    return reactIs_development;
  hasRequiredReactIs_development = 1;
  if (true) {
    (function() {
      var hasSymbol = typeof Symbol === "function" && Symbol.for;
      var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103;
      var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106;
      var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107;
      var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108;
      var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114;
      var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109;
      var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110;
      var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for("react.async_mode") : 60111;
      var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 60111;
      var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112;
      var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113;
      var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for("react.suspense_list") : 60120;
      var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115;
      var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116;
      var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121;
      var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 60117;
      var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 60118;
      var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 60119;
      function isValidElementType(type) {
        return typeof type === "string" || typeof type === "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
        type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
      }
      function typeOf(object) {
        if (typeof object === "object" && object !== null) {
          var $$typeof = object.$$typeof;
          switch ($$typeof) {
            case REACT_ELEMENT_TYPE:
              var type = object.type;
              switch (type) {
                case REACT_ASYNC_MODE_TYPE:
                case REACT_CONCURRENT_MODE_TYPE:
                case REACT_FRAGMENT_TYPE:
                case REACT_PROFILER_TYPE:
                case REACT_STRICT_MODE_TYPE:
                case REACT_SUSPENSE_TYPE:
                  return type;
                default:
                  var $$typeofType = type && type.$$typeof;
                  switch ($$typeofType) {
                    case REACT_CONTEXT_TYPE:
                    case REACT_FORWARD_REF_TYPE:
                    case REACT_LAZY_TYPE:
                    case REACT_MEMO_TYPE:
                    case REACT_PROVIDER_TYPE:
                      return $$typeofType;
                    default:
                      return $$typeof;
                  }
              }
            case REACT_PORTAL_TYPE:
              return $$typeof;
          }
        }
        return void 0;
      }
      var AsyncMode = REACT_ASYNC_MODE_TYPE;
      var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
      var ContextConsumer = REACT_CONTEXT_TYPE;
      var ContextProvider = REACT_PROVIDER_TYPE;
      var Element = REACT_ELEMENT_TYPE;
      var ForwardRef = REACT_FORWARD_REF_TYPE;
      var Fragment = REACT_FRAGMENT_TYPE;
      var Lazy = REACT_LAZY_TYPE;
      var Memo = REACT_MEMO_TYPE;
      var Portal = REACT_PORTAL_TYPE;
      var Profiler = REACT_PROFILER_TYPE;
      var StrictMode = REACT_STRICT_MODE_TYPE;
      var Suspense = REACT_SUSPENSE_TYPE;
      var hasWarnedAboutDeprecatedIsAsyncMode = false;
      function isAsyncMode(object) {
        {
          if (!hasWarnedAboutDeprecatedIsAsyncMode) {
            hasWarnedAboutDeprecatedIsAsyncMode = true;
            console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.");
          }
        }
        return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
      }
      function isConcurrentMode(object) {
        return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
      }
      function isContextConsumer(object) {
        return typeOf(object) === REACT_CONTEXT_TYPE;
      }
      function isContextProvider(object) {
        return typeOf(object) === REACT_PROVIDER_TYPE;
      }
      function isElement(object) {
        return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
      }
      function isForwardRef(object) {
        return typeOf(object) === REACT_FORWARD_REF_TYPE;
      }
      function isFragment(object) {
        return typeOf(object) === REACT_FRAGMENT_TYPE;
      }
      function isLazy(object) {
        return typeOf(object) === REACT_LAZY_TYPE;
      }
      function isMemo(object) {
        return typeOf(object) === REACT_MEMO_TYPE;
      }
      function isPortal(object) {
        return typeOf(object) === REACT_PORTAL_TYPE;
      }
      function isProfiler(object) {
        return typeOf(object) === REACT_PROFILER_TYPE;
      }
      function isStrictMode(object) {
        return typeOf(object) === REACT_STRICT_MODE_TYPE;
      }
      function isSuspense(object) {
        return typeOf(object) === REACT_SUSPENSE_TYPE;
      }
      reactIs_development.AsyncMode = AsyncMode;
      reactIs_development.ConcurrentMode = ConcurrentMode;
      reactIs_development.ContextConsumer = ContextConsumer;
      reactIs_development.ContextProvider = ContextProvider;
      reactIs_development.Element = Element;
      reactIs_development.ForwardRef = ForwardRef;
      reactIs_development.Fragment = Fragment;
      reactIs_development.Lazy = Lazy;
      reactIs_development.Memo = Memo;
      reactIs_development.Portal = Portal;
      reactIs_development.Profiler = Profiler;
      reactIs_development.StrictMode = StrictMode;
      reactIs_development.Suspense = Suspense;
      reactIs_development.isAsyncMode = isAsyncMode;
      reactIs_development.isConcurrentMode = isConcurrentMode;
      reactIs_development.isContextConsumer = isContextConsumer;
      reactIs_development.isContextProvider = isContextProvider;
      reactIs_development.isElement = isElement;
      reactIs_development.isForwardRef = isForwardRef;
      reactIs_development.isFragment = isFragment;
      reactIs_development.isLazy = isLazy;
      reactIs_development.isMemo = isMemo;
      reactIs_development.isPortal = isPortal;
      reactIs_development.isProfiler = isProfiler;
      reactIs_development.isStrictMode = isStrictMode;
      reactIs_development.isSuspense = isSuspense;
      reactIs_development.isValidElementType = isValidElementType;
      reactIs_development.typeOf = typeOf;
    })();
  }
  return reactIs_development;
}
var hasRequiredReactIs;
function requireReactIs() {
  if (hasRequiredReactIs)
    return reactIs.exports;
  hasRequiredReactIs = 1;
  if (false) {
    reactIs.exports = requireReactIs_production_min();
  } else {
    reactIs.exports = requireReactIs_development();
  }
  return reactIs.exports;
}
var objectAssign;
var hasRequiredObjectAssign;
function requireObjectAssign() {
  if (hasRequiredObjectAssign)
    return objectAssign;
  hasRequiredObjectAssign = 1;
  var getOwnPropertySymbols = Object.getOwnPropertySymbols;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var propIsEnumerable = Object.prototype.propertyIsEnumerable;
  function toObject(val) {
    if (val === null || val === void 0) {
      throw new TypeError("Object.assign cannot be called with null or undefined");
    }
    return Object(val);
  }
  function shouldUseNative() {
    try {
      if (!Object.assign) {
        return false;
      }
      var test1 = new String("abc");
      test1[5] = "de";
      if (Object.getOwnPropertyNames(test1)[0] === "5") {
        return false;
      }
      var test2 = {};
      for (var i = 0; i < 10; i++) {
        test2["_" + String.fromCharCode(i)] = i;
      }
      var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
        return test2[n];
      });
      if (order2.join("") !== "0123456789") {
        return false;
      }
      var test3 = {};
      "abcdefghijklmnopqrst".split("").forEach(function(letter) {
        test3[letter] = letter;
      });
      if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
        return false;
      }
      return true;
    } catch (err) {
      return false;
    }
  }
  objectAssign = shouldUseNative() ? Object.assign : function(target, source) {
    var from;
    var to = toObject(target);
    var symbols;
    for (var s = 1; s < arguments.length; s++) {
      from = Object(arguments[s]);
      for (var key in from) {
        if (hasOwnProperty.call(from, key)) {
          to[key] = from[key];
        }
      }
      if (getOwnPropertySymbols) {
        symbols = getOwnPropertySymbols(from);
        for (var i = 0; i < symbols.length; i++) {
          if (propIsEnumerable.call(from, symbols[i])) {
            to[symbols[i]] = from[symbols[i]];
          }
        }
      }
    }
    return to;
  };
  return objectAssign;
}
var ReactPropTypesSecret_1;
var hasRequiredReactPropTypesSecret;
function requireReactPropTypesSecret() {
  if (hasRequiredReactPropTypesSecret)
    return ReactPropTypesSecret_1;
  hasRequiredReactPropTypesSecret = 1;
  var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  ReactPropTypesSecret_1 = ReactPropTypesSecret;
  return ReactPropTypesSecret_1;
}
var has;
var hasRequiredHas;
function requireHas() {
  if (hasRequiredHas)
    return has;
  hasRequiredHas = 1;
  has = Function.call.bind(Object.prototype.hasOwnProperty);
  return has;
}
var checkPropTypes_1;
var hasRequiredCheckPropTypes;
function requireCheckPropTypes() {
  if (hasRequiredCheckPropTypes)
    return checkPropTypes_1;
  hasRequiredCheckPropTypes = 1;
  var printWarning = function() {
  };
  if (true) {
    var ReactPropTypesSecret = requireReactPropTypesSecret();
    var loggedTypeFailures = {};
    var has2 = requireHas();
    printWarning = function(text) {
      var message = "Warning: " + text;
      if (typeof console !== "undefined") {
        console.error(message);
      }
      try {
        throw new Error(message);
      } catch (x) {
      }
    };
  }
  function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
    if (true) {
      for (var typeSpecName in typeSpecs) {
        if (has2(typeSpecs, typeSpecName)) {
          var error;
          try {
            if (typeof typeSpecs[typeSpecName] !== "function") {
              var err = Error(
                (componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              err.name = "Invariant Violation";
              throw err;
            }
            error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
          } catch (ex) {
            error = ex;
          }
          if (error && !(error instanceof Error)) {
            printWarning(
              (componentName || "React class") + ": type specification of " + location + " `" + typeSpecName + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof error + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
            );
          }
          if (error instanceof Error && !(error.message in loggedTypeFailures)) {
            loggedTypeFailures[error.message] = true;
            var stack = getStack ? getStack() : "";
            printWarning(
              "Failed " + location + " type: " + error.message + (stack != null ? stack : "")
            );
          }
        }
      }
    }
  }
  checkPropTypes.resetWarningCache = function() {
    if (true) {
      loggedTypeFailures = {};
    }
  };
  checkPropTypes_1 = checkPropTypes;
  return checkPropTypes_1;
}
var factoryWithTypeCheckers;
var hasRequiredFactoryWithTypeCheckers;
function requireFactoryWithTypeCheckers() {
  if (hasRequiredFactoryWithTypeCheckers)
    return factoryWithTypeCheckers;
  hasRequiredFactoryWithTypeCheckers = 1;
  var ReactIs = requireReactIs();
  var assign = requireObjectAssign();
  var ReactPropTypesSecret = requireReactPropTypesSecret();
  var has2 = requireHas();
  var checkPropTypes = requireCheckPropTypes();
  var printWarning = function() {
  };
  if (true) {
    printWarning = function(text) {
      var message = "Warning: " + text;
      if (typeof console !== "undefined") {
        console.error(message);
      }
      try {
        throw new Error(message);
      } catch (x) {
      }
    };
  }
  function emptyFunctionThatReturnsNull() {
    return null;
  }
  factoryWithTypeCheckers = function(isValidElement, throwOnDirectAccess) {
    var ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
    var FAUX_ITERATOR_SYMBOL = "@@iterator";
    function getIteratorFn(maybeIterable) {
      var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
      if (typeof iteratorFn === "function") {
        return iteratorFn;
      }
    }
    var ANONYMOUS = "<<anonymous>>";
    var ReactPropTypes = {
      array: createPrimitiveTypeChecker("array"),
      bigint: createPrimitiveTypeChecker("bigint"),
      bool: createPrimitiveTypeChecker("boolean"),
      func: createPrimitiveTypeChecker("function"),
      number: createPrimitiveTypeChecker("number"),
      object: createPrimitiveTypeChecker("object"),
      string: createPrimitiveTypeChecker("string"),
      symbol: createPrimitiveTypeChecker("symbol"),
      any: createAnyTypeChecker(),
      arrayOf: createArrayOfTypeChecker,
      element: createElementTypeChecker(),
      elementType: createElementTypeTypeChecker(),
      instanceOf: createInstanceTypeChecker,
      node: createNodeChecker(),
      objectOf: createObjectOfTypeChecker,
      oneOf: createEnumTypeChecker,
      oneOfType: createUnionTypeChecker,
      shape: createShapeTypeChecker,
      exact: createStrictShapeTypeChecker
    };
    function is(x, y) {
      if (x === y) {
        return x !== 0 || 1 / x === 1 / y;
      } else {
        return x !== x && y !== y;
      }
    }
    function PropTypeError(message, data) {
      this.message = message;
      this.data = data && typeof data === "object" ? data : {};
      this.stack = "";
    }
    PropTypeError.prototype = Error.prototype;
    function createChainableTypeChecker(validate) {
      if (true) {
        var manualPropTypeCallCache = {};
        var manualPropTypeWarningCount = 0;
      }
      function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
        componentName = componentName || ANONYMOUS;
        propFullName = propFullName || propName;
        if (secret !== ReactPropTypesSecret) {
          if (throwOnDirectAccess) {
            var err = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            err.name = "Invariant Violation";
            throw err;
          } else if (typeof console !== "undefined") {
            var cacheKey = componentName + ":" + propName;
            if (!manualPropTypeCallCache[cacheKey] && // Avoid spamming the console because they are often not actionable except for lib authors
            manualPropTypeWarningCount < 3) {
              printWarning(
                "You are manually calling a React.PropTypes validation function for the `" + propFullName + "` prop on `" + componentName + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
              );
              manualPropTypeCallCache[cacheKey] = true;
              manualPropTypeWarningCount++;
            }
          }
        }
        if (props[propName] == null) {
          if (isRequired) {
            if (props[propName] === null) {
              return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required " + ("in `" + componentName + "`, but its value is `null`."));
            }
            return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required in " + ("`" + componentName + "`, but its value is `undefined`."));
          }
          return null;
        } else {
          return validate(props, propName, componentName, location, propFullName);
        }
      }
      var chainedCheckType = checkType.bind(null, false);
      chainedCheckType.isRequired = checkType.bind(null, true);
      return chainedCheckType;
    }
    function createPrimitiveTypeChecker(expectedType) {
      function validate(props, propName, componentName, location, propFullName, secret) {
        var propValue = props[propName];
        var propType = getPropType(propValue);
        if (propType !== expectedType) {
          var preciseType = getPreciseType(propValue);
          return new PropTypeError(
            "Invalid " + location + " `" + propFullName + "` of type " + ("`" + preciseType + "` supplied to `" + componentName + "`, expected ") + ("`" + expectedType + "`."),
            { expectedType }
          );
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }
    function createAnyTypeChecker() {
      return createChainableTypeChecker(emptyFunctionThatReturnsNull);
    }
    function createArrayOfTypeChecker(typeChecker) {
      function validate(props, propName, componentName, location, propFullName) {
        if (typeof typeChecker !== "function") {
          return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside arrayOf.");
        }
        var propValue = props[propName];
        if (!Array.isArray(propValue)) {
          var propType = getPropType(propValue);
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an array."));
        }
        for (var i = 0; i < propValue.length; i++) {
          var error = typeChecker(propValue, i, componentName, location, propFullName + "[" + i + "]", ReactPropTypesSecret);
          if (error instanceof Error) {
            return error;
          }
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }
    function createElementTypeChecker() {
      function validate(props, propName, componentName, location, propFullName) {
        var propValue = props[propName];
        if (!isValidElement(propValue)) {
          var propType = getPropType(propValue);
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement."));
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }
    function createElementTypeTypeChecker() {
      function validate(props, propName, componentName, location, propFullName) {
        var propValue = props[propName];
        if (!ReactIs.isValidElementType(propValue)) {
          var propType = getPropType(propValue);
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }
    function createInstanceTypeChecker(expectedClass) {
      function validate(props, propName, componentName, location, propFullName) {
        if (!(props[propName] instanceof expectedClass)) {
          var expectedClassName = expectedClass.name || ANONYMOUS;
          var actualClassName = getClassName(props[propName]);
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + actualClassName + "` supplied to `" + componentName + "`, expected ") + ("instance of `" + expectedClassName + "`."));
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }
    function createEnumTypeChecker(expectedValues) {
      if (!Array.isArray(expectedValues)) {
        if (true) {
          if (arguments.length > 1) {
            printWarning(
              "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
            );
          } else {
            printWarning("Invalid argument supplied to oneOf, expected an array.");
          }
        }
        return emptyFunctionThatReturnsNull;
      }
      function validate(props, propName, componentName, location, propFullName) {
        var propValue = props[propName];
        for (var i = 0; i < expectedValues.length; i++) {
          if (is(propValue, expectedValues[i])) {
            return null;
          }
        }
        var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
          var type = getPreciseType(value);
          if (type === "symbol") {
            return String(value);
          }
          return value;
        });
        return new PropTypeError("Invalid " + location + " `" + propFullName + "` of value `" + String(propValue) + "` " + ("supplied to `" + componentName + "`, expected one of " + valuesString + "."));
      }
      return createChainableTypeChecker(validate);
    }
    function createObjectOfTypeChecker(typeChecker) {
      function validate(props, propName, componentName, location, propFullName) {
        if (typeof typeChecker !== "function") {
          return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside objectOf.");
        }
        var propValue = props[propName];
        var propType = getPropType(propValue);
        if (propType !== "object") {
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an object."));
        }
        for (var key in propValue) {
          if (has2(propValue, key)) {
            var error = typeChecker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
            if (error instanceof Error) {
              return error;
            }
          }
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }
    function createUnionTypeChecker(arrayOfTypeCheckers) {
      if (!Array.isArray(arrayOfTypeCheckers)) {
        true ? printWarning("Invalid argument supplied to oneOfType, expected an instance of array.") : void 0;
        return emptyFunctionThatReturnsNull;
      }
      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];
        if (typeof checker !== "function") {
          printWarning(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + getPostfixForTypeWarning(checker) + " at index " + i + "."
          );
          return emptyFunctionThatReturnsNull;
        }
      }
      function validate(props, propName, componentName, location, propFullName) {
        var expectedTypes = [];
        for (var i2 = 0; i2 < arrayOfTypeCheckers.length; i2++) {
          var checker2 = arrayOfTypeCheckers[i2];
          var checkerResult = checker2(props, propName, componentName, location, propFullName, ReactPropTypesSecret);
          if (checkerResult == null) {
            return null;
          }
          if (checkerResult.data && has2(checkerResult.data, "expectedType")) {
            expectedTypes.push(checkerResult.data.expectedType);
          }
        }
        var expectedTypesMessage = expectedTypes.length > 0 ? ", expected one of type [" + expectedTypes.join(", ") + "]" : "";
        return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`" + expectedTypesMessage + "."));
      }
      return createChainableTypeChecker(validate);
    }
    function createNodeChecker() {
      function validate(props, propName, componentName, location, propFullName) {
        if (!isNode(props[propName])) {
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`, expected a ReactNode."));
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }
    function invalidValidatorError(componentName, location, propFullName, key, type) {
      return new PropTypeError(
        (componentName || "React class") + ": " + location + " type `" + propFullName + "." + key + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + type + "`."
      );
    }
    function createShapeTypeChecker(shapeTypes) {
      function validate(props, propName, componentName, location, propFullName) {
        var propValue = props[propName];
        var propType = getPropType(propValue);
        if (propType !== "object") {
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
        }
        for (var key in shapeTypes) {
          var checker = shapeTypes[key];
          if (typeof checker !== "function") {
            return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
          }
          var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
          if (error) {
            return error;
          }
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }
    function createStrictShapeTypeChecker(shapeTypes) {
      function validate(props, propName, componentName, location, propFullName) {
        var propValue = props[propName];
        var propType = getPropType(propValue);
        if (propType !== "object") {
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
        }
        var allKeys = assign({}, props[propName], shapeTypes);
        for (var key in allKeys) {
          var checker = shapeTypes[key];
          if (has2(shapeTypes, key) && typeof checker !== "function") {
            return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
          }
          if (!checker) {
            return new PropTypeError(
              "Invalid " + location + " `" + propFullName + "` key `" + key + "` supplied to `" + componentName + "`.\nBad object: " + JSON.stringify(props[propName], null, "  ") + "\nValid keys: " + JSON.stringify(Object.keys(shapeTypes), null, "  ")
            );
          }
          var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
          if (error) {
            return error;
          }
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }
    function isNode(propValue) {
      switch (typeof propValue) {
        case "number":
        case "string":
        case "undefined":
          return true;
        case "boolean":
          return !propValue;
        case "object":
          if (Array.isArray(propValue)) {
            return propValue.every(isNode);
          }
          if (propValue === null || isValidElement(propValue)) {
            return true;
          }
          var iteratorFn = getIteratorFn(propValue);
          if (iteratorFn) {
            var iterator = iteratorFn.call(propValue);
            var step;
            if (iteratorFn !== propValue.entries) {
              while (!(step = iterator.next()).done) {
                if (!isNode(step.value)) {
                  return false;
                }
              }
            } else {
              while (!(step = iterator.next()).done) {
                var entry = step.value;
                if (entry) {
                  if (!isNode(entry[1])) {
                    return false;
                  }
                }
              }
            }
          } else {
            return false;
          }
          return true;
        default:
          return false;
      }
    }
    function isSymbol(propType, propValue) {
      if (propType === "symbol") {
        return true;
      }
      if (!propValue) {
        return false;
      }
      if (propValue["@@toStringTag"] === "Symbol") {
        return true;
      }
      if (typeof Symbol === "function" && propValue instanceof Symbol) {
        return true;
      }
      return false;
    }
    function getPropType(propValue) {
      var propType = typeof propValue;
      if (Array.isArray(propValue)) {
        return "array";
      }
      if (propValue instanceof RegExp) {
        return "object";
      }
      if (isSymbol(propType, propValue)) {
        return "symbol";
      }
      return propType;
    }
    function getPreciseType(propValue) {
      if (typeof propValue === "undefined" || propValue === null) {
        return "" + propValue;
      }
      var propType = getPropType(propValue);
      if (propType === "object") {
        if (propValue instanceof Date) {
          return "date";
        } else if (propValue instanceof RegExp) {
          return "regexp";
        }
      }
      return propType;
    }
    function getPostfixForTypeWarning(value) {
      var type = getPreciseType(value);
      switch (type) {
        case "array":
        case "object":
          return "an " + type;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + type;
        default:
          return type;
      }
    }
    function getClassName(propValue) {
      if (!propValue.constructor || !propValue.constructor.name) {
        return ANONYMOUS;
      }
      return propValue.constructor.name;
    }
    ReactPropTypes.checkPropTypes = checkPropTypes;
    ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
    ReactPropTypes.PropTypes = ReactPropTypes;
    return ReactPropTypes;
  };
  return factoryWithTypeCheckers;
}
if (true) {
  ReactIs = requireReactIs();
  throwOnDirectAccess = true;
  propTypes$1.exports = requireFactoryWithTypeCheckers()(ReactIs.isElement, throwOnDirectAccess);
} else {
  propTypes$1.exports = requireFactoryWithThrowingShims()();
}
var ReactIs;
var throwOnDirectAccess;
var propTypesExports = propTypes$1.exports;
var namespace = "react-swiftreveal";
var defaults = { duration: 1e3, delay: 0, count: 1 };
var ssr = true;
var observerMode = false;
var raf = (cb) => setTimeout(cb, 66);
var disableSsr = () => {
  ssr = false;
};
var fadeOutEnabled = false;
var globalHide = false;
var collapseend;
var counter = 1;
var effectMap = {};
var sheet = null;
var name$c = `${namespace}-${Math.floor(Math.random() * 1e15)}-`;
var insertRule = (rule2) => {
  try {
    return sheet == null ? void 0 : sheet.insertRule(rule2, sheet.cssRules.length);
  } catch (e) {
    console.warn("react-swiftreveal - animation failed");
  }
};
var cascade = (i, start, end, duration, total) => {
  const minv = Math.log(duration);
  const maxv = Math.log(total);
  const scale = (maxv - minv) / (end - start);
  return Math.exp(minv + scale * (i - start));
};
var animation = (effect) => {
  if (!sheet)
    return "";
  const rule2 = `@keyframes ${name$c + counter}{${effect}}`;
  const effectId = effectMap[effect];
  if (!effectId) {
    insertRule(rule2);
    effectMap[effect] = counter;
    return `${name$c}${counter++}`;
  }
  return `${name$c}${effectId}`;
};
var hideAll = () => {
  if (globalHide)
    return;
  globalHide = true;
  window.removeEventListener("scroll", hideAll, true);
  insertRule(`.${namespace} { opacity: 0; }`);
  window.removeEventListener("orientationchange", hideAll, true);
  window.document.removeEventListener("visibilitychange", hideAll);
};
if (typeof window !== "undefined" && window.name !== "nodejs" && window.document && typeof navigator !== "undefined") {
  observerMode = "IntersectionObserver" in window && "IntersectionObserverEntry" in window && "intersectionRatio" in window.IntersectionObserverEntry.prototype && /\{\s*\[native code\]\s*\}/.test(`${IntersectionObserver}`);
  raf = window.requestAnimationFrame || raf;
  ssr = window.document.querySelectorAll("div[data-reactroot]").length > 0;
  if (navigator.appVersion.includes("MSIE 10"))
    ;
  if (ssr && "performance" in window && "timing" in window.performance && "domContentLoadedEventEnd" in window.performance.timing && window.performance.timing.domLoading && Date.now() - window.performance.timing.domLoading < 300)
    ssr = false;
  if (ssr)
    window.setTimeout(disableSsr, 1500);
  if (!observerMode) {
    collapseend = document.createEvent("Event");
    collapseend.initEvent("collapseend", true, true);
  }
  const element = document.createElement("style");
  document.head.appendChild(element);
  if (element.sheet && element.sheet.cssRules) {
    sheet = element.sheet;
    window.addEventListener("scroll", hideAll, true);
    window.addEventListener("orientationchange", hideAll, true);
    window.document.addEventListener("visibilitychange", hideAll);
  }
}
var inOut = propTypesExports.shape({
  make: propTypesExports.func,
  duration: propTypesExports.number.isRequired,
  delay: propTypesExports.number.isRequired,
  forever: propTypesExports.bool,
  count: propTypesExports.number.isRequired,
  style: propTypesExports.object.isRequired,
  reverse: propTypesExports.bool
});
var propTypes = {
  //when: any,
  //spy: any,
  //margin: number,
  collapse: propTypesExports.bool,
  // oneOfType([bool, shape({ tag: string, props: object })]),
  collapseEl: propTypesExports.element,
  cascade: propTypesExports.bool,
  wait: propTypesExports.number,
  //    step: oneOfType([instanceOf(Step), string]),
  force: propTypesExports.bool,
  disabled: propTypesExports.bool,
  appear: propTypesExports.bool,
  enter: propTypesExports.bool,
  exit: propTypesExports.bool,
  fraction: propTypesExports.number,
  //children: element.isRequired,
  refProp: propTypesExports.string,
  innerRef: propTypesExports.func,
  onReveal: propTypesExports.func,
  //onEnter: func,
  //onEntering: func,
  //onEntered: func,
  //onExit: func,
  //onExiting: func,
  //onExited: func,
  unmountOnExit: propTypesExports.bool,
  mountOnEnter: propTypesExports.bool,
  inEffect: inOut.isRequired,
  outEffect: propTypesExports.oneOfType([inOut, propTypesExports.oneOf([false])]).isRequired,
  ssrReveal: propTypesExports.bool,
  collapseOnly: propTypesExports.bool,
  ssrFadeout: propTypesExports.bool
};
var defaultProps = {
  fraction: 0.2,
  //when: true,
  refProp: "ref"
  //margin: 0,
};
var contextTypes = {
  transitionGroup: propTypesExports.object
};
var RevealBase = class _RevealBase extends import_react.default.Component {
  //getChildContext() {
  //  return { transitionGroup: null }; // allows for nested Transitions
  //}
  constructor(props, context) {
    super(props, context);
    this.isOn = props.when !== void 0 ? !!props.when : true;
    this.state = {
      collapse: props.collapse ? _RevealBase.getInitialCollapseStyle(props) : void 0,
      style: {
        opacity: (!this.isOn || props.ssrReveal) && props.outEffect ? 0 : void 0
        //visibility: props.when  ? 'visible' : 'hidden',
      }
    };
    this.savedChild = false;
    this.isShown = false;
    if (!observerMode) {
      this.revealHandler = this.makeHandler(this.reveal);
      this.resizeHandler = this.makeHandler(this.resize);
    } else
      this.handleObserve = this.handleObserve.bind(this);
    this.saveRef = this.saveRef.bind(this);
  }
  saveRef(node) {
    if (this.childRef)
      this.childRef(node);
    if (this.props.innerRef)
      this.props.innerRef(node);
    if (this.el !== node) {
      this.el = node && "offsetHeight" in node ? node : void 0;
      this.observe(this.props, true);
    }
  }
  invisible() {
    if (!this || !this.el)
      return;
    this.savedChild = false;
    if (!this.isShown) {
      this.setState({
        hasExited: true,
        collapse: this.props.collapse ? { ...this.state.collapse, visibility: "hidden" } : null,
        style: {
          /*...this.state.style, visibility: 'hidden'*/
          opacity: 0
        }
        /*, collapsing: false */
      });
      if (!observerMode && this.props.collapse)
        window.document.dispatchEvent(collapseend);
    }
  }
  animationEnd(func2, cascade2, { forever, count, delay, duration }) {
    if (forever)
      return;
    const handler = () => {
      if (!this || !this.el)
        return;
      this.animationEndTimeout = void 0;
      func2.call(this);
    };
    this.animationEndTimeout = window.setTimeout(handler, delay + (duration + (cascade2 ? duration : 0) * count));
  }
  getDimensionValue() {
    return this.el.offsetHeight + parseInt(window.getComputedStyle(this.el, null).getPropertyValue("margin-top"), 10) + parseInt(window.getComputedStyle(this.el, null).getPropertyValue("margin-bottom"), 10);
  }
  //    //const delta = this.props.duration>>2,
  //    //      duration = delta,
  //    //      delay = this.props.delay + (this.isOn ? 0 : this.props.duration - delta)
  collapse(state, props, inOut2) {
    const total = inOut2.duration + (props.cascade ? inOut2.duration : 0), height = this.isOn ? this.getDimensionValue() : 0;
    let duration, delay;
    if (props.collapseOnly) {
      duration = inOut2.duration / 3;
      delay = inOut2.delay;
    } else {
      let delta1 = total >> 2, delta2 = delta1 >> 1;
      duration = delta1;
      delay = inOut2.delay + (this.isOn ? 0 : total - delta1 - delta2);
      state.style.animationDuration = `${total - delta1 + (this.isOn ? delta2 : -delta2)}ms`;
      state.style.animationDelay = `${inOut2.delay + (this.isOn ? delta1 - delta2 : 0)}ms`;
    }
    state.collapse = {
      height,
      transition: `height ${duration}ms ease ${delay}ms`,
      // padding ${duration}ms ease ${delay}ms, border ${duration}ms ease ${delay}ms`,
      overflow: props.collapseOnly ? "hidden" : void 0
      //margin: 0, padding: 0, border: '1px solid transparent',
      //boxSizing: 'border-box',
    };
    return state;
  }
  animate(props) {
    if (!this || !this.el)
      return;
    this.unlisten();
    if (this.isShown === this.isOn)
      return;
    this.isShown = this.isOn;
    const leaving = !this.isOn && props.outEffect, inOut2 = props[leaving ? "outEffect" : "inEffect"];
    let animationName = "style" in inOut2 && inOut2.style.animationName || void 0;
    let state;
    if (!props.collapseOnly) {
      if ((props.outEffect || this.isOn) && inOut2.make)
        animationName = inOut2.make;
      state = {
        /* status: leaving ? 'exiting':'entering',*/
        hasAppeared: true,
        hasExited: false,
        collapse: void 0,
        style: {
          ...inOut2.style,
          animationDuration: `${inOut2.duration}ms`,
          animationDelay: `${inOut2.delay}ms`,
          animationIterationCount: inOut2.forever ? "infinite" : inOut2.count,
          opacity: 1,
          //visibility: 'visible',
          animationName
        },
        className: inOut2.className
      };
    } else
      state = { hasAppeared: true, hasExited: false, style: { opacity: 1 } };
    this.setState(props.collapse ? this.collapse(state, props, inOut2) : state);
    if (leaving) {
      this.savedChild = import_react.default.cloneElement(this.getChild());
      this.animationEnd(this.invisible, props.cascade, inOut2);
    } else
      this.savedChild = false;
    this.onReveal(props);
  }
  onReveal(props) {
    if (props.onReveal && this.isOn) {
      if (this.onRevealTimeout)
        this.onRevealTimeout = window.clearTimeout(this.onRevealTimeout);
      props.wait ? this.onRevealTimeout = window.setTimeout(props.onReveal, props.wait) : props.onReveal();
    }
  }
  componentWillUnmount() {
    this.unlisten();
    ssr && disableSsr();
  }
  handleObserve([entry], observer) {
    if (entry.intersectionRatio > 0) {
      observer.disconnect();
      this.observer = null;
      this.reveal(this.props, true);
    }
  }
  observe(props, update = false) {
    if (!this.el)
      return;
    if (observerMode) {
      if (this.observer) {
        if (update)
          this.observer.disconnect();
        else
          return;
      } else if (update)
        return;
      this.observer = new IntersectionObserver(this.handleObserve, { threshold: props.fraction });
      this.observer.observe(this.el);
    }
  }
  reveal(props, inView = false) {
    if (!globalHide)
      hideAll();
    if (!this || !this.el)
      return;
    if (!props)
      props = this.props;
    if (ssr)
      disableSsr();
    if (this.isOn && this.isShown && props.spy !== void 0) {
      this.isShown = false;
      this.setState({ style: {} });
      window.setTimeout(() => this.reveal(props), 200);
    } else if (inView || this.inViewport(props) || props.force)
      this.animate(props);
    else
      observerMode ? this.observe(props) : this.listen();
  }
  componentDidMount() {
    if (!this.el || this.props.disabled)
      return;
    if (!this.props.collapseOnly) {
      if ("make" in this.props.inEffect)
        this.props.inEffect.make(false, this.props);
      if (this.props.when !== void 0 && this.props.outEffect && "make" in this.props.outEffect)
        this.props.outEffect.make(true, this.props);
    }
    const parentGroup = this.context.transitionGroup;
    const appear = parentGroup && !parentGroup.isMounting ? !("enter" in this.props && this.props.enter === false) : this.props.appear;
    if (this.isOn && ((this.props.when !== void 0 || this.props.spy !== void 0) && !appear || ssr && !fadeOutEnabled && !this.props.ssrFadeout && this.props.outEffect && !this.props.ssrReveal && _RevealBase.getTop(this.el) < window.pageYOffset + window.innerHeight)) {
      this.isShown = true;
      this.setState({
        hasAppeared: true,
        collapse: this.props.collapse ? { height: this.getDimensionValue() } : this.state.collapse,
        style: { opacity: 1 }
      });
      this.onReveal(this.props);
      return;
    }
    if (ssr && this.props.ssrFadeout && this.props.outEffect && _RevealBase.getTop(this.el) < window.pageYOffset + window.innerHeight) {
      this.setState({ style: { opacity: 0, transition: "opacity 1000ms 1000ms" } });
      window.setTimeout(() => this.reveal(this.props, true), 2e3);
      return;
    }
    if (this.isOn)
      this.props.force ? this.animate(this.props) : this.reveal(this.props);
  }
  cascade(children) {
    let newChildren;
    if (typeof children === "string") {
      newChildren = children.split("").map((ch, index) => import_react.default.createElement("span", { key: index, style: { display: "inline-block", whiteSpace: "pre" } }, ch));
    } else
      newChildren = import_react.default.Children.toArray(children);
    let { duration, reverse } = this.props[this.isOn || !this.props.outEffect ? "inEffect" : "outEffect"], count = newChildren.length, total = duration * 2;
    if (this.props.collapse) {
      total = parseInt(this.state.style.animationDuration, 10);
      duration = total / 2;
    }
    let i = reverse ? count : 0;
    newChildren = newChildren.map((child) => typeof child === "object" && child ? import_react.default.cloneElement(child, {
      style: {
        ...child.props.style,
        ...this.state.style,
        animationDuration: Math.round(cascade(reverse ? i-- : i++, 0, count, duration, total)) + "ms"
      }
      //ref: i === count? (el => this.finalEl = el) : void 0,
    }) : child);
    return newChildren;
  }
  static getInitialCollapseStyle(props) {
    return {
      height: 0,
      visibility: props.when ? void 0 : "hidden"
    };
  }
  componentWillReceiveProps(props) {
    if (props.when !== void 0)
      this.isOn = !!props.when;
    if (props.fraction !== this.props.fraction)
      this.observe(props, true);
    if (!this.isOn && props.onExited && "exit" in props && props.exit === false) {
      props.onExited();
      return;
    }
    if (props.disabled)
      return;
    if (props.collapse && !this.props.collapse) {
      this.setState({ style: {}, collapse: _RevealBase.getInitialCollapseStyle(props) });
      this.isShown = false;
    }
    if (props.when !== this.props.when || props.spy !== this.props.spy)
      this.reveal(props);
    if (this.onRevealTimeout && !this.isOn)
      this.onRevealTimeout = window.clearTimeout(this.onRevealTimeout);
  }
  getChild() {
    if (this.savedChild && !this.props.disabled)
      return this.savedChild;
    if (typeof this.props.children === "object") {
      const child = import_react.default.Children.only(this.props.children);
      return "type" in child && typeof child.type === "string" || this.props.refProp !== "ref" ? child : import_react.default.createElement("div", null, child);
    } else
      return import_react.default.createElement("div", null, this.props.children);
  }
  render() {
    let mount;
    if (!this.state.hasAppeared)
      mount = !this.props.mountOnEnter || this.isOn;
    else
      mount = !this.props.unmountOnExit || !this.state.hasExited || this.isOn;
    const child = this.getChild();
    if (typeof child.ref === "function")
      this.childRef = child.ref;
    let newChildren = false, { style, className, children } = child.props;
    let newClass = this.props.disabled ? className : `${this.props.outEffect ? namespace : ""}${this.state.className ? " " + this.state.className : ""}${className ? " " + className : ""}` || void 0, newStyle;
    if (typeof this.state.style.animationName === "function")
      this.state.style.animationName = this.state.style.animationName(!this.isOn, this.props);
    if (this.props.cascade && !this.props.disabled && children && this.state.style.animationName) {
      newChildren = this.cascade(children);
      newStyle = { ...style, opacity: 1 };
    } else
      newStyle = this.props.disabled ? style : { ...style, ...this.state.style };
    const props = { ...this.props.props, className: newClass, style: newStyle, [this.props.refProp]: this.saveRef };
    const el = import_react.default.cloneElement(child, props, mount ? newChildren || children : void 0);
    if (this.props.collapse !== void 0)
      return this.props.collapseEl ? import_react.default.cloneElement(this.props.collapseEl, { style: { ...this.props.collapseEl.style, ...this.props.disabled ? void 0 : this.state.collapse }, children: el }) : import_react.default.createElement("div", { style: this.props.disabled ? void 0 : this.state.collapse, children: el });
    return el;
  }
  makeHandler(handler) {
    const update = () => {
      handler.call(this, this.props);
      this.ticking = false;
    };
    return () => {
      if (!this.ticking) {
        raf(update);
        this.ticking = true;
      }
    };
  }
  static getTop(el) {
    while (el.offsetTop === void 0)
      el = el.parentNode;
    let top = el.offsetTop;
    for (; el.offsetParent; top += el.offsetTop)
      el = el.offsetParent;
    return top;
  }
  inViewport(props) {
    if (!this.el || window.document.hidden)
      return false;
    const h = this.el.offsetHeight, delta = window.pageYOffset - _RevealBase.getTop(this.el), tail = Math.min(h, window.innerHeight) * (globalHide ? props.fraction : 0);
    return delta > tail - window.innerHeight && delta < h - tail;
  }
  resize(props) {
    if (!this || !this.el || !this.isOn)
      return;
    if (this.inViewport(props)) {
      this.unlisten();
      this.isShown = this.isOn;
      this.setState({ hasExited: !this.isOn, hasAppeared: true, collapse: void 0, style: { opacity: this.isOn || !props.outEffect ? 1 : 0 } });
      this.onReveal(props);
    }
  }
  listen() {
    if (!observerMode && !this.isListener) {
      this.isListener = true;
      window.addEventListener("scroll", this.revealHandler, { passive: true });
      window.addEventListener("orientationchange", this.revealHandler, { passive: true });
      window.document.addEventListener("visibilitychange", this.revealHandler, { passive: true });
      window.document.addEventListener("collapseend", this.revealHandler, { passive: true });
      window.addEventListener("resize", this.resizeHandler, { passive: true });
    }
  }
  unlisten() {
    if (!observerMode && this.isListener) {
      window.removeEventListener("scroll", this.revealHandler, { passive: true });
      window.removeEventListener("orientationchange", this.revealHandler, { passive: true });
      window.document.removeEventListener("visibilitychange", this.revealHandler, { passive: true });
      window.document.removeEventListener("collapseend", this.revealHandler, { passive: true });
      window.removeEventListener("resize", this.resizeHandler, { passive: true });
      this.isListener = false;
    }
    if (this.onRevealTimeout)
      this.onRevealTimeout = window.clearTimeout(this.onRevealTimeout);
    if (this.animationEndTimeout)
      this.animationEndTimeout = window.clearTimeout(this.animationEndTimeout);
  }
};
RevealBase.propTypes = propTypes;
RevealBase.defaultProps = defaultProps;
RevealBase.contextTypes = contextTypes;
RevealBase.displayName = "RevealBase";
var RevealBase$1 = RevealBase;
function wrapper(props, inEffect, outEffect, children) {
  if ("in" in props)
    props.when = props.in;
  if (import_react.default.Children.count(children) < 2)
    return import_react.default.createElement(RevealBase$1, { ...props, inEffect, outEffect, children });
  children = import_react.default.Children.map(
    children,
    (child) => import_react.default.createElement(RevealBase$1, { ...props, inEffect, outEffect, children: child })
  );
  return "Fragment" in import_react.default ? import_react.default.createElement(import_react.default.Fragment, null, children) : import_react.default.createElement("span", null, children);
}
var rule$b = `
 from, 20%, 53%, 80%, to {
    animation-timing-function: cubic-bezier(0.215, 0.610, 0.355, 1.000);
    transform: translate3d(0,0,0);
  }

  40%, 43% {
    animation-timing-function: cubic-bezier(0.755, 0.050, 0.855, 0.060);
    transform: translate3d(0, -30px, 0);
  }

  70% {
    animation-timing-function: cubic-bezier(0.755, 0.050, 0.855, 0.060);
    transform: translate3d(0, -15px, 0);
  }

  90% {
    transform: translate3d(0, -4px, 0);
}
`;
var name$b;
function make$i() {
  return name$b || (name$b = animation(rule$b));
}
function Jump({
  children,
  // eslint-disable-next-line unused-imports/no-unused-vars
  out,
  timeout,
  duration = defaults.duration,
  delay = defaults.delay,
  count = defaults.count,
  forever,
  ...props
} = defaults) {
  const effect = { make: make$i, duration: timeout === void 0 ? duration : timeout, delay, forever, count, style: { animationFillMode: "both" } };
  return wrapper(props, effect, false, children);
}
var rule$a = `
  from {
    transform: scale(1);
  }

  50% {
    transform: scale(1.1);
  }

  to {
    transform: scale(1);
  }
`;
var name$a;
function make$h() {
  return name$a || (name$a = animation(rule$a));
}
function Pop({
  children,
  // eslint-disable-next-line unused-imports/no-unused-vars
  out,
  timeout,
  duration = defaults.duration,
  delay = defaults.delay,
  count = defaults.count,
  forever,
  ...props
} = defaults) {
  const effect = { make: make$h, duration: timeout === void 0 ? duration : timeout, delay, forever, count, style: { animationFillMode: "both" } };
  return wrapper(props, effect, false, children);
}
var rule$9 = `
  from, 11.1%, to {
    transform: none;
  }

  22.2% {
    transform: skewX(-12.5deg) skewY(-12.5deg);
  }

  33.3% {
    transform: skewX(6.25deg) skewY(6.25deg);
  }

  44.4% {
    transform: skewX(-3.125deg) skewY(-3.125deg);
  }

  55.5% {
    transform: skewX(1.5625deg) skewY(1.5625deg);
  }

  66.6% {
    transform: skewX(-0.78125deg) skewY(-0.78125deg);
  }

  77.7% {
    transform: skewX(0.390625deg) skewY(0.390625deg);
  }

  88.8% {
    transform: skewX(-0.1953125deg) skewY(-0.1953125deg);
}
`;
var name$9;
function make$g() {
  return name$9 || (name$9 = animation(rule$9));
}
function Jello({
  children,
  // eslint-disable-next-line unused-imports/no-unused-vars
  out,
  timeout,
  duration = defaults.duration,
  delay = defaults.delay,
  count = defaults.count,
  forever,
  ...props
} = defaults) {
  const effect = { make: make$g, duration: timeout === void 0 ? duration : timeout, delay, forever, count, style: { animationFillMode: "both" } };
  return wrapper(props, effect, false, children);
}
var rule$8 = `
from, 50%, to {
    opacity: 1;
  }

  25%, 75% {
    opacity: 0;
}
`;
var name$8;
function make$f() {
  return name$8 || (name$8 = animation(rule$8));
}
function Flash({
  children,
  // eslint-disable-next-line unused-imports/no-unused-vars
  out,
  timeout,
  duration = defaults.duration,
  delay = defaults.delay,
  count = defaults.count,
  forever,
  ...props
} = defaults) {
  const effect = { make: make$f, duration: timeout === void 0 ? duration : timeout, delay, forever, count, style: { animationFillMode: "both" } };
  return wrapper(props, effect, false, children);
}
var rule$7 = `
  0% {
    transform: translateX(0);
  }

  6.5% {
    transform: translateX(-6px) rotateY(-9deg);
  }

  18.5% {
    transform: translateX(5px) rotateY(7deg);
  }

  31.5% {
    transform: translateX(-3px) rotateY(-5deg);
  }

  43.5% {
    transform: translateX(2px) rotateY(3deg);
  }

  50% {
    transform: translateX(0);
}
`;
var name$7;
function make$e() {
  return name$7 || (name$7 = animation(rule$7));
}
function HeadShake({
  children,
  // eslint-disable-next-line unused-imports/no-unused-vars
  out,
  timeout,
  duration = defaults.duration,
  delay = defaults.delay,
  count = defaults.count,
  forever,
  ...props
} = defaults) {
  const effect = { make: make$e, duration: timeout === void 0 ? duration : timeout, delay, forever, count, style: { animationFillMode: "both" } };
  return wrapper(props, effect, false, children);
}
var rule$6 = `
	from {
    transform: scale3d(1, 1, 1);
  }

  50% {
    transform: scale3d(1.05, 1.05, 1.05);
  }

  to {
    transform: scale3d(1, 1, 1);
}`;
var name$6;
function make$d() {
  return name$6 || (name$6 = animation(rule$6));
}
function Pulse({
  children,
  // eslint-disable-next-line unused-imports/no-unused-vars
  out,
  timeout,
  duration = defaults.duration,
  delay = defaults.delay,
  count = defaults.count,
  forever,
  ...props
} = defaults) {
  const effect = { make: make$d, duration: timeout === void 0 ? duration : timeout, delay, forever, count, style: { animationFillMode: "both" } };
  return wrapper(props, effect, false, children);
}
var rule$5 = `
 from {
    transform: scale3d(1, 1, 1);
  }

  30% {
    transform: scale3d(1.25, 0.75, 1);
  }

  40% {
    transform: scale3d(0.75, 1.25, 1);
  }

  50% {
    transform: scale3d(1.15, 0.85, 1);
  }

  65% {
    transform: scale3d(.95, 1.05, 1);
  }

  75% {
    transform: scale3d(1.05, .95, 1);
  }

  to {
    transform: scale3d(1, 1, 1);
}
`;
var name$5;
function make$c() {
  return name$5 || (name$5 = animation(rule$5));
}
function RubberBand({
  children,
  // eslint-disable-next-line unused-imports/no-unused-vars
  out,
  timeout,
  duration = defaults.duration,
  delay = defaults.delay,
  count = defaults.count,
  forever,
  ...props
} = defaults) {
  const effect = { make: make$c, duration: timeout === void 0 ? duration : timeout, delay, forever, count, style: { animationFillMode: "both" } };
  return wrapper(props, effect, false, children);
}
var rule$4 = `
  from, to {
    transform: translate3d(0, 0, 0);
  }

  10%, 30%, 50%, 70%, 90% {
    transform: translate3d(-10px, 0, 0);
  }

  20%, 40%, 60%, 80% {
    transform: translate3d(10px, 0, 0);
  }
`;
var name$4 = animation(rule$4);
function Shake({
  children,
  // eslint-disable-next-line unused-imports/no-unused-vars
  out,
  timeout,
  duration = defaults.duration,
  delay = defaults.delay,
  count = defaults.count,
  forever,
  ...props
} = defaults) {
  const effect = { make: () => name$4, duration: timeout === void 0 ? duration : timeout, delay, forever, count, style: { animationFillMode: "both" } };
  return wrapper(props, effect, false, children);
}
var rule$3 = `
    from {
        transform: rotate(360deg);
        animation-timing-function: linear;
    }

    to {
       transform: rotate(0deg);
    }
`;
var name$3;
function make$b() {
  return name$3 || (name$3 = animation(rule$3));
}
function Spin({
  children,
  // eslint-disable-next-line unused-imports/no-unused-vars
  out,
  timeout,
  duration = defaults.duration,
  delay = defaults.delay,
  count = defaults.count,
  forever,
  ...props
} = defaults) {
  const effect = { make: make$b, duration: timeout === void 0 ? duration : timeout, delay, forever, count, style: { animationFillMode: "both" } };
  return wrapper(props, effect, false, children);
}
var rule$2 = `
    20% {
        transform: rotate3d(0, 0, 1, 15deg);
    }

    40% {
        transform: rotate3d(0, 0, 1, -10deg);
    }

    60% {
        transform: rotate3d(0, 0, 1, 5deg);
    }

    80% {
        transform: rotate3d(0, 0, 1, -5deg);
    }

    to {
        transform: rotate3d(0, 0, 1, 0deg);
    }
`;
var name$2;
function make$a() {
  return name$2 || (name$2 = animation(rule$2));
}
function Swing({
  children,
  // eslint-disable-next-line unused-imports/no-unused-vars
  out,
  timeout,
  duration = defaults.duration,
  delay = defaults.delay,
  count = defaults.count,
  forever,
  ...props
} = defaults) {
  const effect = { make: make$a, duration: timeout === void 0 ? duration : timeout, delay, forever, count, style: { animationFillMode: "both" } };
  return wrapper(props, effect, false, children);
}
var rule$1 = `
    from {
        transform: scale3d(1, 1, 1);
    }

    10%, 20% {
        transform: scale3d(.9, .9, .9) rotate3d(0, 0, 1, -3deg);
    }

    30%, 50%, 70%, 90% {
        transform: scale3d(1.1, 1.1, 1.1) rotate3d(0, 0, 1, 3deg);
    }

    40%, 60%, 80% {
        transform: scale3d(1.1, 1.1, 1.1) rotate3d(0, 0, 1, -3deg);
    }

    to {
        transform: scale3d(1, 1, 1);
    }
`;
var name$1;
function make$9() {
  return name$1 || (name$1 = animation(rule$1));
}
function Tada({
  children,
  // eslint-disable-next-line unused-imports/no-unused-vars
  out,
  timeout,
  duration = defaults.duration,
  delay = defaults.delay,
  count = defaults.count,
  forever,
  ...props
} = defaults) {
  const effect = { make: make$9, duration: timeout === void 0 ? duration : timeout, delay, forever, count, style: { animationFillMode: "both" } };
  return wrapper(props, effect, false, children);
}
var rule = `
    from {
        transform: none;
    }

    15% {
        transform: translate3d(-25%, 0, 0) rotate3d(0, 0, 1, -5deg);
    }

    30% {
        transform: translate3d(20%, 0, 0) rotate3d(0, 0, 1, 3deg);
    }

    45% {
        transform: translate3d(-15%, 0, 0) rotate3d(0, 0, 1, -3deg);
    }

    60% {
        transform: translate3d(10%, 0, 0) rotate3d(0, 0, 1, 2deg);
    }

    75% {
        transform: translate3d(-5%, 0, 0) rotate3d(0, 0, 1, -1deg);
    }

    to {
        transform: none;
    }
`;
var name;
function make$8() {
  return name || (name = animation(rule));
}
function Wobble({
  children,
  // eslint-disable-next-line unused-imports/no-unused-vars
  out,
  timeout,
  duration = defaults.duration,
  delay = defaults.delay,
  count = defaults.count,
  forever,
  ...props
} = defaults) {
  const effect = { make: make$8, duration: timeout === void 0 ? duration : timeout, delay, forever, count, style: { animationFillMode: "both" } };
  return wrapper(props, effect, false, children);
}
var lookup$7 = {};
function make$7(reverse, { left, right, up, down, top, bottom, mirror, opposite }) {
  const checksum = (left ? 1 : 0) | (right ? 2 : 0) | (top || down ? 4 : 0) | (bottom || up ? 8 : 0) | (mirror ? 16 : 0) | (opposite ? 32 : 0) | (reverse ? 64 : 0);
  if (lookup$7.hasOwnProperty(checksum))
    return lookup$7[checksum];
  if (!mirror !== !(reverse && opposite))
    [left, right, top, bottom, up, down] = [right, left, bottom, top, down, up];
  let angle = "-200deg";
  let origin = "center";
  if ((down || top) && left)
    angle = "-45deg";
  if ((down || top) && right || (up || bottom) && left)
    angle = "45deg";
  if ((up || bottom) && right)
    angle = "-90deg";
  if (left || right)
    origin = `${left ? "left" : "right"} bottom`;
  lookup$7[checksum] = animation(`
    ${!reverse ? "from" : "to"} { opacity: 0; transform-origin: ${origin}; transform: rotate3d(0, 0, 1, ${angle});}
    ${reverse ? "from" : "to"} { opacity: 1; transform-origin: ${origin}; transform: none;}
  `);
  return lookup$7[checksum];
}
function Rotate({
  children,
  // eslint-disable-next-line unused-imports/no-unused-vars
  out,
  forever,
  timeout,
  duration = defaults.duration,
  delay = defaults.delay,
  count = defaults.count,
  ...props
} = defaults) {
  const effect = {
    make: make$7,
    duration: timeout === void 0 ? duration : timeout,
    delay,
    forever,
    count,
    style: { animationFillMode: "both" }
  };
  return wrapper(props, effect, effect, children);
}
var lookup$6 = {};
function make$6(reverse, { left, right, up, down, top, bottom, mirror, opposite }) {
  const checksum = (left ? 1 : 0) | (right ? 2 : 0) | (top || down ? 4 : 0) | (bottom || up ? 8 : 0) | (mirror ? 16 : 0) | (opposite ? 32 : 0) | (reverse ? 64 : 0);
  if (lookup$6.hasOwnProperty(checksum))
    return lookup$6[checksum];
  if (!mirror !== !(reverse && opposite))
    [left, right, top, bottom, up, down] = [right, left, bottom, top, down, up];
  const transformX = left || right;
  const transformY = top || bottom || up || down;
  const transform = transformX || transformY;
  let rule2, x0, y0, x20, y20, y40, x60, y60, x75, y75, x90, y90, x100, y100;
  if (reverse) {
    x20 = transformX ? `${right ? "-" : ""}20px` : 0;
    y20 = transformY ? `${up || bottom ? "" : "-"}10px` : "0";
    y40 = `${down || top ? "" : "-"}20px`;
    x100 = transformX ? `${left ? "-" : ""}2000px` : "0";
    y100 = transformY ? `${down || top ? "-" : ""}2000px` : "0";
  } else {
    x0 = transformX ? `${left ? "-" : ""}3000px` : "0";
    y0 = transformY ? `${down || top ? "-" : ""}3000px` : "0";
    x60 = transformX ? `${right ? "-" : ""}25px` : "0";
    y60 = transformY ? `${up || bottom ? "-" : ""}25px` : "0";
    x75 = transformX ? `${left ? "-" : ""}10px` : "0";
    y75 = transformY ? `${down || top ? "-" : ""}10px` : "0";
    x90 = transformX ? `${right ? "-" : ""}5px` : "0";
    y90 = transformY ? `${up || bottom ? "-" : ""}5px` : "0";
  }
  if (transform) {
    rule2 = reverse ? `
        20% {
          transform: translate3d(${x20}, ${y20}, 0);
          }
        ${transformY ? `40%, 45% {
            opacity: 1;
            transform: translate3d(0, ${y40}, 0);
          }` : ""}
          to {
            opacity: 0;
            transform: translate3d(${x100}, ${y100}, 0);
        }
      ` : `from, 60%, 75%, 90%, to {
        animation-timing-function: cubic-bezier(0.215, 0.610, 0.355, 1.000);
      }
      from {
        opacity: 0;
        transform: translate3d(${x0}, ${y0}, 0);
      }
      60% {
        opacity: 1;
        transform: translate3d(${x60}, ${y60}, 0);
      }
      75% {
        transform: translate3d(${x75}, ${y75}, 0);
      }
      90% {
        transform: translate3d(${x90}, ${y90}, 0);
      }
      to {
        transform: none;
      }`;
  } else {
    rule2 = reverse ? `20% {
          transform: scale3d(.9, .9, .9);
        }
        50%, 55% {
          opacity: 1;
          transform: scale3d(1.1, 1.1, 1.1);
        }
        to {
          opacity: 0;
          transform: scale3d(.3, .3, .3);
      }` : `from, 20%, 40%, 60%, 80%, to {
        animation-timing-function: cubic-bezier(0.215, 0.610, 0.355, 1.000);
      }
      0% {
        opacity: 0;
        transform: scale3d(.3, .3, .3);
      }
      20% {
        transform: scale3d(1.1, 1.1, 1.1);
      }
      40% {
        transform: scale3d(.9, .9, .9);
      }
      60% {
        opacity: 1;
        transform: scale3d(1.03, 1.03, 1.03);
      }
      80% {
        transform: scale3d(.97, .97, .97);
      }
      to {
        opacity: 1;
        transform: scale3d(1, 1, 1);
      }`;
  }
  lookup$6[checksum] = animation(rule2);
  return lookup$6[checksum];
}
function Bounce({
  children,
  // eslint-disable-next-line unused-imports/no-unused-vars
  out,
  forever,
  timeout,
  duration = defaults.duration,
  delay = defaults.delay,
  count = defaults.count,
  ...props
} = defaults) {
  const effect = {
    make: make$6,
    duration: timeout === void 0 ? duration : timeout,
    delay,
    forever,
    count,
    style: { animationFillMode: "both" },
    reverse: props.left
  };
  return wrapper(props, effect, effect, children);
}
var lookup$5 = {};
function make$5(reverse, { distance, left, right, up, down, top, bottom, big, mirror, opposite }) {
  const checksum = (distance ? distance.toString() : 0) + ((left ? 1 : 0) | (right ? 2 : 0) | (top || down ? 4 : 0) | (bottom || up ? 8 : 0) | (mirror ? 16 : 0) | (opposite ? 32 : 0) | (reverse ? 64 : 0) | (big ? 128 : 0));
  if (lookup$5.hasOwnProperty(checksum))
    return lookup$5[checksum];
  const transform = left || right || up || down || top || bottom;
  let x, y;
  if (transform) {
    if (!mirror !== !(reverse && opposite))
      [left, right, top, bottom, up, down] = [right, left, bottom, top, down, up];
    const dist = distance || (big ? "2000px" : "100%");
    x = left ? `-${dist}` : right ? dist : "0";
    y = down || top ? `-${dist}` : up || bottom ? dist : "0";
  }
  lookup$5[checksum] = animation(
    `${!reverse ? "from" : "to"} {opacity: 0;${transform ? ` transform: translate3d(${x}, ${y}, 0);` : ""}}
     ${reverse ? "from" : "to"} {opacity: 1;transform: none;} `
  );
  return lookup$5[checksum];
}
function Fade({
  children,
  // eslint-disable-next-line unused-imports/no-unused-vars
  out,
  forever,
  timeout,
  duration = defaults.duration,
  delay = defaults.delay,
  count = defaults.count,
  ...props
} = defaults) {
  const effect = {
    make: make$5,
    duration: timeout === void 0 ? duration : timeout,
    delay,
    forever,
    count,
    style: { animationFillMode: "both" },
    reverse: props.left
  };
  return wrapper(props, effect, effect, children);
}
var lookup$4 = {};
function make$4(reverse, { left, right, top, bottom, x, y, mirror, opposite }) {
  const checksum = (left ? 1 : 0) | (right || y ? 2 : 0) | (top || x ? 4 : 0) | (bottom ? 8 : 0) | (mirror ? 16 : 0) | (opposite ? 32 : 0) | (reverse ? 64 : 0);
  if (lookup$4.hasOwnProperty(checksum))
    return lookup$4[checksum];
  if (!mirror !== !(reverse && opposite))
    [left, right, top, bottom, x, y] = [right, left, bottom, top, y, x];
  let rule2;
  if (x || y || left || right || top || bottom) {
    const xval = x || top || bottom ? `${bottom ? "-" : ""}1` : "0";
    const yval = y || right || left ? `${left ? "-" : ""}1` : "0";
    if (!reverse) {
      rule2 = `from {
          transform: perspective(400px) rotate3d(${xval}, ${yval}, 0, 90deg);
          animation-timing-function: ease-in;
          opacity: 0;
        }
        40% {
          transform: perspective(400px) rotate3d(${xval}, ${yval}, 0, -20deg);
          animation-timing-function: ease-in;
        }
        60% {
          transform: perspective(400px) rotate3d(${xval}, ${yval}, 0, 10deg);
          opacity: 1;
        }
        80% {
          transform: perspective(400px) rotate3d(${xval}, ${yval}, 0, -5deg);
        }
        to {
          transform: perspective(400px);
        }`;
    } else {
      rule2 = `from {
          transform: perspective(400px);
        }
        30% {
          transform: perspective(400px) rotate3d(${xval}, ${yval}, 0, -15deg);
          opacity: 1;
        }
        to {
          transform: perspective(400px) rotate3d(${xval}, ${yval}, 0, 90deg);
          opacity: 0;
        }`;
    }
  } else {
    rule2 = `from {
          transform: perspective(400px) rotate3d(0, 1, 0, -360deg);
          animation-timing-function: ease-out;
          opacity: ${!reverse ? "0" : "1"};
        }
        40% {
          transform: perspective(400px) translate3d(0, 0, 150px) rotate3d(0, 1, 0, -190deg);
          animation-timing-function: ease-out;
        }
        50% {
          transform: perspective(400px) translate3d(0, 0, 150px) rotate3d(0, 1, 0, -170deg);
          animation-timing-function: ease-in;
        }
        to {
          transform: perspective(400px);
          animation-timing-function: ease-in;
          opacity: ${reverse ? "0" : "1"};
        }`;
  }
  lookup$4[checksum] = animation(rule2);
  return lookup$4[checksum];
}
function Flip({
  children,
  // eslint-disable-next-line unused-imports/no-unused-vars
  out,
  forever,
  timeout,
  duration = defaults.duration,
  delay = defaults.delay,
  count = defaults.count,
  ...props
} = defaults) {
  const effect = {
    make: make$4,
    duration: timeout === void 0 ? duration : timeout,
    delay,
    forever,
    count,
    style: { animationFillMode: "both", backfaceVisibility: "visible" }
  };
  return wrapper(props, effect, effect, children);
}
var lookup$3 = {};
function make$3(reverse, { left, right, mirror, opposite }) {
  const checksum = (left ? 1 : 0) | (right ? 2 : 0) | (mirror ? 16 : 0) | (opposite ? 32 : 0) | (reverse ? 64 : 0);
  if (lookup$3.hasOwnProperty(checksum))
    return lookup$3[checksum];
  if (!mirror !== !(reverse && opposite))
    [left, right] = [right, left];
  const dist = "100%";
  const x = left ? `-${dist}` : right ? dist : "0";
  const rule2 = !reverse ? `from {
        transform: translate3d(${x}, 0, 0) skewX(-30deg);
        opacity: 0;
      }
      60% {
        transform: skewX(20deg);
        opacity: 1;
      }
      80% {
        transform: skewX(-5deg);
        opacity: 1;
      }
      to {
        transform: none;
        opacity: 1;
      }` : `from {
        opacity: 1;
      }
      to {
        transform: translate3d(${x}, 0, 0) skewX(30deg);
        opacity: 0;
      }
    `;
  lookup$3[checksum] = animation(rule2);
  return lookup$3[checksum];
}
function LightSpeed({
  children,
  // eslint-disable-next-line unused-imports/no-unused-vars
  out,
  forever,
  timeout,
  duration = defaults.duration,
  delay = defaults.delay,
  count = defaults.count,
  ...props
} = defaults) {
  const effect = {
    make: make$3,
    duration: timeout === void 0 ? duration : timeout,
    delay,
    forever,
    count,
    style: { animationFillMode: "both" }
  };
  0 + (props.left ? 1 : 0) + (props.right ? 10 : 0) + (props.mirror ? 1e4 : 0) + (props.opposite ? 1e5 : 0);
  return wrapper(props, effect, effect, children);
}
var lookup$2 = {};
function make$2(reverse, { left, right, up, down, top, bottom, big, mirror, opposite }) {
  const checksum = (left ? 1 : 0) | (right ? 2 : 0) | (top || down ? 4 : 0) | (bottom || up ? 8 : 0) | (mirror ? 16 : 0) | (opposite ? 32 : 0) | (reverse ? 64 : 0) | (big ? 128 : 0);
  if (lookup$2.hasOwnProperty(checksum))
    return lookup$2[checksum];
  if (!mirror !== !(reverse && opposite))
    [left, right, top, bottom, up, down] = [right, left, bottom, top, down, up];
  const dist = big ? "2000px" : "100%";
  const x = left ? `-${dist}` : right ? dist : "0";
  const y = down || top ? `-${dist}` : up || bottom ? dist : "0";
  lookup$2[checksum] = animation(`
    ${!reverse ? "from" : "to"} {opacity: 0;transform: translate3d(${x}, ${y}, 0) rotate3d(0, 0, 1, -120deg);}
	  ${reverse ? "from" : "to"} {opacity: 1;transform: none}
  `);
  return lookup$2[checksum];
}
function Roll({
  children,
  // eslint-disable-next-line unused-imports/no-unused-vars
  out,
  forever,
  timeout,
  duration = defaults.duration,
  delay = defaults.delay,
  count = defaults.count,
  ...props
} = defaults) {
  const effect = {
    make: make$2,
    duration: timeout === void 0 ? duration : timeout,
    delay,
    forever,
    count,
    style: { animationFillMode: "both" }
  };
  return wrapper(props, effect, effect, children);
}
var lookup$1 = {};
function make$1(reverse, { left, right, up, down, top, bottom, big, mirror, opposite }) {
  const checksum = (left ? 1 : 0) | (right ? 2 : 0) | (top || down ? 4 : 0) | (bottom || up ? 8 : 0) | (mirror ? 16 : 0) | (opposite ? 32 : 0) | (reverse ? 64 : 0) | (big ? 128 : 0);
  if (lookup$1.hasOwnProperty(checksum))
    return lookup$1[checksum];
  const transform = left || right || up || down || top || bottom;
  let x, y;
  if (transform) {
    if (!mirror !== !(reverse && opposite))
      [left, right, top, bottom, up, down] = [right, left, bottom, top, down, up];
    const dist = big ? "2000px" : "100%";
    x = left ? `-${dist}` : right ? dist : "0";
    y = down || top ? `-${dist}` : up || bottom ? dist : "0";
  }
  lookup$1[checksum] = animation(
    `${!reverse ? "from" : "to"} {${transform ? ` transform: translate3d(${x}, ${y}, 0);` : ""}}
     ${reverse ? "from" : "to"} {transform: none;} `
  );
  return lookup$1[checksum];
}
function Slide({
  children,
  // eslint-disable-next-line unused-imports/no-unused-vars
  out,
  forever,
  timeout,
  duration = defaults.duration,
  delay = defaults.delay,
  count = defaults.count,
  ...props
} = defaults) {
  const effect = {
    make: make$1,
    duration: timeout === void 0 ? duration : timeout,
    delay,
    forever,
    count,
    style: { animationFillMode: "both" },
    reverse: props.left
  };
  return wrapper(props, effect, effect, children);
}
var lookup = {};
function make(reverse, { left, right, up, down, top, bottom, mirror, opposite }) {
  const checksum = (left ? 1 : 0) | (right ? 2 : 0) | (top || down ? 4 : 0) | (bottom || up ? 8 : 0) | (mirror ? 16 : 0) | (opposite ? 32 : 0) | (reverse ? 64 : 0);
  if (lookup.hasOwnProperty(checksum))
    return lookup[checksum];
  if (!mirror !== !(reverse && opposite))
    [left, right, top, bottom, up, down] = [right, left, bottom, top, down, up];
  const transformX = left || right;
  const transformY = top || bottom || up || down;
  const transform = transformX || transformY;
  let rule2, x1, y1, x2, y2;
  if (transform) {
    if (reverse) {
      x1 = transformX ? `${left ? "" : "-"}42px` : "0";
      y1 = transformY ? `${down || top ? "-" : ""}60px` : "0";
      x2 = transformX ? `${right ? "" : "-"}2000px` : "0";
      y2 = transformY ? `${up || bottom ? "" : "-"}2000px` : "0";
      rule2 = `40% {
          opacity: 1;
          transform: scale3d(.475, .475, .475) translate3d(${x1}, ${y1}, 0);
        }
        to {
          opacity: 0;
          transform: scale(.1) translate3d(${x2}, ${y2}, 0);
          transform-origin: ${transformY ? "center bottom" : `${left ? "left" : "right"} center`};
        }`;
    } else {
      x1 = transformX ? `${left ? "-" : ""}1000px` : "0";
      y1 = transformY ? `${down || top ? "-" : ""}1000px` : "0";
      x2 = transformX ? `${right ? "-" : ""}10px` : "0";
      y2 = transformY ? `${up || bottom ? "-" : ""}60px` : "0";
      rule2 = `from {
          opacity: 0;
          transform: scale3d(.1, .1, .1) translate3d(${x1}, ${y1}, 0);
          animation-timing-function: cubic-bezier(0.550, 0.055, 0.675, 0.190);
        }
        60% {
          opacity: 1;
          transform: scale3d(.475, .475, .475) translate3d(${x2}, ${y2}, 0);
          animation-timing-function: cubic-bezier(0.175, 0.885, 0.320, 1);
        }`;
    }
  } else {
    rule2 = `${!reverse ? "from" : "to"} {opacity: 0; transform: scale3d(.1, .1, .1);} ${reverse ? "from" : "to"} { opacity: 1; transform: none;}`;
  }
  lookup[checksum] = animation(rule2);
  return lookup[checksum];
}
function Zoom({
  // eslint-disable-next-line unused-imports/no-unused-vars
  children,
  out,
  forever,
  timeout,
  duration = defaults.duration,
  delay = defaults.delay,
  count = defaults.count,
  ...props
} = defaults) {
  const effect = {
    make,
    duration: timeout === void 0 ? duration : timeout,
    delay,
    forever,
    count,
    style: { animationFillMode: "both" },
    reverse: props.left
  };
  return wrapper(props, effect, effect, children);
}
export {
  Bounce,
  Fade,
  Flash,
  Flip,
  HeadShake,
  Jello,
  Jump,
  LightSpeed,
  Pop,
  Pulse,
  Roll,
  Rotate,
  RubberBand,
  Shake,
  Slide,
  Spin,
  Swing,
  Tada,
  Wobble,
  Zoom
};
/*! Bundled license information:

react-swift-reveal/dist/index.mjs:
  (** @license React v16.13.1
   * react-is.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-swift-reveal/dist/index.mjs:
  (** @license React v16.13.1
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
  (*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  *)
*/
//# sourceMappingURL=react-swift-reveal.js.map
